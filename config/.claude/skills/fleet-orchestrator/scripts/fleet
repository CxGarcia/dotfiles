#!/usr/bin/env bun
import { Command } from "commander"
import { $ } from "bun"
import { readFileSync, writeFileSync, existsSync, mkdirSync, appendFileSync, readdirSync, rmSync } from "fs"
import { join, basename, resolve } from "path"
import { homedir } from "os"

const FMT_CMD = "#{pane_current_command}"
const FMT_DEAD = "#{pane_dead}"
const FMT_DEAD_STATUS = "#{pane_dead_status}"
const FMT_SESSION_ID = "#{session_id}"
const FMT_PANE_TITLE = "#{pane_title}"
const FMT_SESSIONS = "#{session_id} #{session_name}"

const FLEET_DIR = join(homedir(), ".claude", "fleet")
const REGISTRY = join(FLEET_DIR, "registry.json")
const EVENTS = join(FLEET_DIR, "events.jsonl")
const REPOS = join(FLEET_DIR, "repos.json")

mkdirSync(FLEET_DIR, { recursive: true })
if (!existsSync(REGISTRY)) writeFileSync(REGISTRY, JSON.stringify({ version: 1, updated: "", features: {} }))
if (!existsSync(EVENTS)) writeFileSync(EVENTS, "")
if (!existsSync(REPOS)) writeFileSync(REPOS, "{}")

const ts = () => new Date().toISOString()

function readRegistry(): Registry {
  return JSON.parse(readFileSync(REGISTRY, "utf-8"))
}

function writeRegistry(reg: Registry) {
  const tmp = `${REGISTRY}.tmp`
  writeFileSync(tmp, JSON.stringify(reg, null, 2))
  const { renameSync } = require("fs")
  renameSync(tmp, REGISTRY)
}

function updateFeature(name: string, updates: Partial<Feature>) {
  const reg = readRegistry()
  if (!reg.features[name]) return
  Object.assign(reg.features[name], updates, { updatedAt: ts() })
  reg.updated = ts()
  writeRegistry(reg)
}

function getFeature(name: string): Feature | null {
  return readRegistry().features[name] ?? null
}

function requireFeature(name: string): Feature {
  const feat = getFeature(name)
  if (!feat) {
    console.error(`ERROR: Feature '${name}' not found`)
    process.exit(1)
  }
  return feat
}

function logEvent(feature: string, event: string, extra: Record<string, unknown> = {}) {
  const entry = JSON.stringify({ ts: ts(), feature, event, ...extra })
  appendFileSync(EVENTS, entry + "\n")
}

function readRepos(): Record<string, string> {
  return JSON.parse(readFileSync(REPOS, "utf-8"))
}

function writeRepos(repos: Record<string, string>) {
  writeFileSync(REPOS, JSON.stringify(repos, null, 2))
}

function resolveRepo(input: string): string | null {
  const expanded = input.replace(/^~/, homedir())
  if (existsSync(expanded)) return resolve(expanded)

  const repos = readRepos()
  if (repos[input] && existsSync(repos[input])) return repos[input]

  const fuzzy = Object.entries(repos).find(([k]) => k.includes(input))
  if (fuzzy && existsSync(fuzzy[1])) return fuzzy[1]

  return null
}

async function tmuxSend(session: string, text: string) {
  await $`tmux send-keys -t ${session}:claude -l ${text}`.quiet()
  await Bun.sleep(500)
  await $`tmux send-keys -t ${session}:claude Enter`.quiet()
}

async function sessionExists(target: string): Promise<boolean> {
  const result = await $`tmux has-session -t ${target}`.quiet().nothrow()
  return result.exitCode === 0
}

async function waitForReady(session: string, maxWait = 120): Promise<boolean> {
  const target = `${session}:claude`
  for (let elapsed = 0; elapsed < maxWait; elapsed += 2) {
    const cmd = (await $`tmux display-message -t ${target} -p ${FMT_CMD}`.quiet().nothrow()).text().trim()
    if (cmd === "claude") {
      const content = (await $`tmux capture-pane -t ${target} -p -S -5`.quiet().nothrow()).text()
      const hasPrompt = content.includes("❯")
      const hasSpinner = /ctrl.c to interrupt|tokens/.test(content)
      if (hasPrompt && !hasSpinner) {
        await Bun.sleep(2000)
        return true
      }
    }
    await Bun.sleep(2000)
  }
  return false
}

async function checkSessionState(target: string): Promise<string> {
  if (!await sessionExists(target)) return "gone"

  const cmd = (await $`tmux display-message -t ${target} -p ${FMT_CMD}`.quiet().nothrow()).text().trim()

  if (cmd !== "claude") {
    const dead = (await $`tmux display-message -t ${target} -p ${FMT_DEAD}`.quiet().nothrow()).text().trim()
    if (dead === "1") {
      const code = (await $`tmux display-message -t ${target} -p ${FMT_DEAD_STATUS}`.quiet().nothrow()).text().trim()
      return code === "0" ? "exited" : `crashed:${code}`
    }
    return "exited"
  }

  const content = (await $`tmux capture-pane -t ${target} -p -S -10`.quiet().nothrow()).text()

  if (/\[y\/n\]|\[Y\/n\]|\[yes\/no\]/.test(content)) return "blocked"
  if (/(?:↑\/↓|↑↓).*select|to select.*Enter|Space to select/.test(content)) return "picker"
  if (/ctrl\+c to interrupt|·.*tokens/.test(content)) return "working"
  if (content.includes("❯")) return "idle"

  return "unknown"
}

interface Feature {
  description: string
  repo: string
  worktreePath: string
  branch: string
  tmuxSession: string
  tmuxSessionId: string
  phase: string
  phaseHistory: string[]
  mode: string
  pr: { number: number; url?: string; ciStatus: string; lastChecked: string } | null
  status: string
  startedAt: string
  updatedAt: string
  artifacts: Record<string, string>
}

interface Registry {
  version: number
  updated: string
  features: Record<string, Feature>
}

const fleet = new Command("fleet")
  .description("Manage concurrent Claude Code feature sessions")
  .version("1.0.0")

fleet.command("spawn")
  .description("Create a new feature session with its own worktree")
  .argument("<name>", "Feature name (kebab-case)")
  .argument("<repo>", "Repository path or shortname from repos index")
  .argument("[description]", "Feature description")
  .option("--mode <mode>", "Pipeline mode: phased, slfg, or fix", "phased")
  .action(async (name, repoInput, description, opts) => {
    const resolved = resolveRepo(repoInput)
    if (!resolved) {
      console.error(`ERROR: '${repoInput}' is not a directory and not in repos index. Run 'fleet repos list' to see known repos.`)
      process.exit(1)
    }
    const repo = resolve(resolved)

    const isGit = await $`git -C ${repo} rev-parse --git-dir`.quiet().nothrow()
    if (isGit.exitCode !== 0) {
      console.error(`ERROR: ${repo} is not a git repository`)
      process.exit(1)
    }

    const repos = readRepos()
    repos[basename(repo)] = repo
    writeRepos(repos)

    const existing = getFeature(name)
    if (existing && (existing.status === "active" || existing.status === "blocked")) {
      console.error(`ERROR: Feature '${name}' already exists with status '${existing.status}'`)
      process.exit(1)
    }

    let sessionName = name
    let n = 2
    while (await sessionExists(sessionName)) {
      sessionName = `${name}-${n++}`
    }

    const worktreePath = join(repo, ".claude", "worktrees", name)
    const branch = `worktree-${name}`

    if (existsSync(worktreePath)) {
      console.log(`WORKTREE_EXISTS: ${worktreePath}`)
    } else {
      let defaultBranch = (await $`git -C ${repo} symbolic-ref refs/remotes/origin/HEAD`.quiet().nothrow()).text().trim().replace("refs/remotes/origin/", "")
      if (!defaultBranch) defaultBranch = "main"
      await $`git -C ${repo} fetch origin ${defaultBranch} --quiet`.quiet().nothrow()
      mkdirSync(join(repo, ".claude", "worktrees"), { recursive: true })
      const wt = await $`git -C ${repo} worktree add -b ${branch} ${worktreePath} origin/${defaultBranch}`.nothrow()
      console.log(wt.text())
      console.log(`WORKTREE_CREATED: ${worktreePath} (branch: ${branch})`)
    }

    await $`tmux new-session -d -s ${sessionName} -n claude -c ${worktreePath}`.quiet()
    await $`tmux set-option -t ${sessionName} @fleet_managed 1`.quiet()
    if (description) await $`tmux set-option -t ${sessionName} @claude_task ${description}`.quiet()

    // Create util window at index 2 in the base repo (not the worktree)
    await $`tmux new-window -d -t ${sessionName}:2 -n util -c ${repo}`.quiet().nothrow()
    await $`tmux split-window -d -v -t ${sessionName}:2 -c ${repo}`.quiet().nothrow()
    await $`tmux set-option -w -t ${sessionName}:2 monitor-activity off`.quiet().nothrow()
    await $`tmux select-window -t ${sessionName}:1`.quiet().nothrow()

    const sessionId = (await $`tmux display-message -t ${sessionName} -p ${FMT_SESSION_ID}`.quiet()).text().trim()
    console.log(`SESSION_CREATED: ${sessionName} (id: ${sessionId})`)

    await tmuxSend(sessionName, "claude --dangerously-skip-permissions")

    console.log("WAITING_FOR_CLAUDE...")
    if (!await waitForReady(sessionName, 120)) {
      console.error(`ERROR: Claude did not become ready within 120s`)
      console.error(`SESSION: ${sessionName} (you can attach manually)`)
      process.exit(1)
    }
    console.log("CLAUDE_READY")

    let initialCmd: string
    switch (opts.mode) {
      case "slfg": initialCmd = `/slfg ${description ?? ""}`; break
      case "fix": initialCmd = description ?? ""; break
      default: initialCmd = `/workflows:brainstorm ${description ?? ""}`; break
    }

    await tmuxSend(sessionName, initialCmd)
    console.log(`COMMAND_SENT: ${initialCmd}`)

    const phase = opts.mode === "slfg" ? "slfg" : opts.mode === "fix" ? "fix" : "brainstorm"

    const reg = readRegistry()
    reg.features[name] = {
      description: description ?? "",
      repo,
      worktreePath,
      branch,
      tmuxSession: sessionName,
      tmuxSessionId: sessionId,
      phase,
      phaseHistory: ["spawned"],
      mode: opts.mode,
      pr: null,
      status: "active",
      startedAt: ts(),
      updatedAt: ts(),
      artifacts: {},
    }
    reg.updated = ts()
    writeRegistry(reg)
    logEvent(name, "spawned", { phase })
    console.log(`REGISTERED: ${name} (${opts.mode} mode, phase: ${phase})`)
  })

fleet.command("status")
  .description("Dashboard of all active features")
  .action(async () => {
    const reg = readRegistry()
    const active = Object.entries(reg.features).filter(([, f]) => f.status !== "done" && f.status !== "abandoned")

    if (active.length === 0) {
      console.log("NO_ACTIVE_FEATURES")
      return
    }

    console.log("FEATURES:")
    for (const [name, feat] of active) {
      const liveState = await checkSessionState(feat.tmuxSession)
      const repoName = basename(feat.repo)

      let prInfo = ""
      let prUrl = ""
      if (feat.pr) {
        prInfo = `PR #${feat.pr.number} (${feat.pr.ciStatus ?? "unknown"})`
        prUrl = feat.pr.url ?? ""
        if (!prUrl) {
          prUrl = (await $`gh pr view ${feat.pr.number} --repo ${feat.repo} --json url -q .url`.quiet().nothrow()).text().trim()
        }
      }

      let title = ""
      if (liveState !== "gone") {
        title = (await $`tmux display-message -t ${feat.tmuxSessionId} -p ${FMT_PANE_TITLE}`.quiet().nothrow()).text().trim()
        title = title.replace(/^.*?\s/, "")
        if (title === "Claude Code") title = ""
      }

      console.log(`NAME=${name} PHASE=${feat.phase} STATUS=${feat.status} LIVE=${liveState} REPO=${repoName} PR=${prInfo} PR_URL=${prUrl} TASK=${title}`)
    }
  })

fleet.command("check")
  .description("Detailed state of one feature")
  .argument("<name>", "Feature name")
  .action(async (name) => {
    const feat = requireFeature(name)
    const state = await checkSessionState(feat.tmuxSession)
    console.log(`FEATURE=${name} PHASE=${feat.phase} STATE=${state}`)

    if (["idle", "working", "blocked", "picker"].includes(state)) {
      console.log("PANE_OUTPUT:")
      const content = (await $`tmux capture-pane -t ${feat.tmuxSessionId} -p -S -5`.quiet().nothrow()).text()
      console.log(content)
    }
  })

fleet.command("send")
  .description("Send a command to an idle session")
  .argument("<name>", "Feature name")
  .argument("<command...>", "Command text to send")
  .action(async (name, command) => {
    const feat = requireFeature(name)
    const state = await checkSessionState(feat.tmuxSession)
    if (state !== "idle") {
      console.error(`ERROR: Session is not idle (state: ${state}). Cannot send command.`)
      process.exit(1)
    }
    await tmuxSend(feat.tmuxSession, command.join(" "))
    console.log(`SENT: ${command.join(" ")}`)
  })

fleet.command("pick")
  .description("Select option N in a Claude Code picker")
  .argument("<name>", "Feature name")
  .argument("<number>", "Option number to select")
  .action(async (name, number) => {
    if (!/^\d+$/.test(number)) {
      console.error("ERROR: Choice must be a number (e.g., 1, 2, 3)")
      process.exit(1)
    }
    const feat = requireFeature(name)
    const state = await checkSessionState(feat.tmuxSession)
    if (state !== "picker") {
      console.error(`ERROR: Session is not showing a picker (state: ${state}).`)
      console.error(`  Use 'fleet check ${name}' to see the current pane output.`)
      process.exit(1)
    }
    await $`tmux send-keys -t ${feat.tmuxSession}:claude ${number}`.quiet()
    console.log(`PICKED: option ${number}`)
  })

fleet.command("keys")
  .description("Send raw tmux key names (Down, Enter, Escape, etc.)")
  .argument("<name>", "Feature name")
  .argument("<keys...>", "Key names to send")
  .action(async (name, keys) => {
    const feat = requireFeature(name)
    await $`tmux send-keys -t ${feat.tmuxSession}:claude ${keys}`.quiet()
    console.log(`KEYS_SENT: ${keys.join(" ")}`)
  })

fleet.command("advance")
  .description("Advance a feature to the next pipeline phase")
  .argument("<name>", "Feature name")
  .action(async (name) => {
    const feat = requireFeature(name)

    if (feat.mode === "slfg") {
      console.error(`ERROR: Feature '${name}' is in slfg mode — it advances autonomously`)
      process.exit(1)
    }

    const state = await checkSessionState(feat.tmuxSession)
    if (state !== "idle") {
      console.error(`ERROR: Session is not idle (state: ${state}). Wait for current phase to complete.`)
      process.exit(1)
    }

    const transitions: Record<string, [string, string]> = {
      brainstorm: ["plan", "/workflows:plan"],
      plan: ["work", "/workflows:work"],
      work: ["review", "/workflows:review latest"],
      review: ["simplify", "Run the code-simplifier agent on changes in this branch. Iterate until nothing left to simplify."],
      simplify: ["pr_monitoring", ""],
    }

    const transition = transitions[feat.phase]
    if (!transition) {
      console.error(`ERROR: Cannot advance from phase '${feat.phase}'`)
      process.exit(1)
    }

    const [nextPhase, nextCmd] = transition
    if (nextCmd) {
      await tmuxSend(feat.tmuxSession, nextCmd)
      console.log(`SENT: ${nextCmd}`)
    }

    const reg = readRegistry()
    reg.features[name].phase = nextPhase
    reg.features[name].phaseHistory.push(feat.phase)
    reg.features[name].updatedAt = ts()
    reg.updated = ts()
    writeRegistry(reg)

    logEvent(name, "phase_complete", { phase: feat.phase })
    logEvent(name, "phase_start", { phase: nextPhase })
    console.log(`ADVANCED: ${name} ${feat.phase} -> ${nextPhase}`)
  })

fleet.command("kill")
  .description("Clean up a feature session: session, worktree, branch")
  .argument("<name>", "Feature name")
  .action(async (name) => {
    const feat = requireFeature(name)
    const { tmuxSessionId: sid, tmuxSession: sname, repo, worktreePath, branch } = feat

    const target = await sessionExists(sid) ? sid : await sessionExists(sname) ? sname : null
    if (target) {
      await $`tmux send-keys -t ${target} C-c`.quiet().nothrow()
      await Bun.sleep(1000)
      await $`tmux send-keys -t ${target} -l /exit`.quiet().nothrow()
      await $`tmux send-keys -t ${target} Enter`.quiet().nothrow()
      await Bun.sleep(2000)
      await $`tmux kill-session -t ${target}`.quiet().nothrow()
      console.log(`SESSION_KILLED: ${sname}`)
    } else {
      console.log(`SESSION_ALREADY_GONE: ${sname}`)
    }

    if (existsSync(worktreePath)) {
      await $`git -C ${repo} worktree remove --force ${worktreePath}`.quiet().nothrow()
      console.log(`WORKTREE_REMOVED: ${worktreePath}`)
    }

    const branchExists = await $`git -C ${repo} rev-parse --verify ${branch}`.quiet().nothrow()
    if (branchExists.exitCode === 0) {
      await $`git -C ${repo} branch -D ${branch}`.quiet().nothrow()
      console.log(`BRANCH_DELETED: ${branch}`)
    }

    const home = homedir()
    for (const prefix of ["teams", "tasks"]) {
      const dir = join(home, ".claude", prefix)
      if (existsSync(dir)) {
        for (const entry of readdirSync(dir)) {
          if (entry.startsWith("work-")) rmSync(join(dir, entry), { recursive: true, force: true })
        }
      }
    }

    updateFeature(name, { status: "abandoned" })
    logEvent(name, "abandoned")
    console.log(`DONE: ${name} abandoned and cleaned up`)
  })

fleet.command("list")
  .description("List fleet-managed tmux sessions")
  .action(async () => {
    const sessions = (await $`tmux list-sessions -F ${FMT_SESSIONS}`.quiet().nothrow()).text().trim()
    if (!sessions) return

    for (const line of sessions.split("\n")) {
      const [id, sname] = line.split(" ")
      const managed = (await $`tmux show-option -qv -t ${sname} @fleet_managed`.quiet().nothrow()).text().trim()
      if (managed === "1") {
        const cmd = (await $`tmux display-message -t ${sname} -p ${FMT_CMD}`.quiet().nothrow()).text().trim()
        console.log(`ID=${id} NAME=${sname} CMD=${cmd}`)
      }
    }
  })

fleet.command("recover")
  .description("Reconcile registry with live tmux sessions, worktrees, and PRs")
  .action(async () => {
    const reg = readRegistry()
    const active = Object.entries(reg.features).filter(([, f]) => f.status === "active" || f.status === "blocked")

    if (active.length === 0) {
      console.log("NO_FEATURES_TO_RECOVER")
      return
    }

    console.log("RECOVERING:")
    for (const [name, feat] of active) {
      const sessionAlive = await sessionExists(feat.tmuxSessionId)
      let claudeRunning = false
      if (sessionAlive) {
        const cmd = (await $`tmux display-message -t ${feat.tmuxSessionId} -p ${FMT_CMD}`.quiet().nothrow()).text().trim()
        claudeRunning = cmd === "claude"
      }
      const worktreeExists = existsSync(feat.worktreePath)

      let prStatus = "none"
      const prJson = (await $`gh pr list --repo ${feat.repo} --head ${feat.branch} --json number,state --limit 1`.quiet().nothrow()).text().trim()
      try {
        const prs = JSON.parse(prJson || "[]")
        if (prs.length > 0) prStatus = `PR #${prs[0].number} (${prs[0].state})`
      } catch {}

      let recoverStatus = "ok"
      if (!sessionAlive) {
        updateFeature(name, { status: "crashed" })
        recoverStatus = "crashed"
      }

      console.log(`NAME=${name} SESSION=${sessionAlive ? "yes" : "no"} CLAUDE=${claudeRunning ? "yes" : "no"} WORKTREE=${worktreeExists ? "yes" : "no"} PR=${prStatus} STATUS=${recoverStatus}`)
    }
  })

fleet.command("monitor")
  .description("Background poller that detects state changes and auto-advances phases")
  .option("--interval <seconds>", "Poll interval in seconds", "30")
  .action(async (opts) => {
    const interval = parseInt(opts.interval) * 1000
    const stateFile = join(FLEET_DIR, ".monitor_state")
    const prevStates = new Map<string, string>()

    if (existsSync(stateFile)) {
      for (const line of readFileSync(stateFile, "utf-8").split("\n").filter(Boolean)) {
        const [k, v] = line.split("=")
        if (k && v) prevStates.set(k, v)
      }
    }

    console.log(`MONITOR_STARTED interval=${opts.interval}s`)

    while (true) {
      const reg = readRegistry()
      const active = Object.entries(reg.features).filter(([, f]) => f.status === "active" || f.status === "blocked")

      for (const [name, feat] of active) {
        const liveState = await checkSessionState(feat.tmuxSession)
        const prev = prevStates.get(name)
        if (liveState === prev) continue

        prevStates.set(name, liveState)
        writeFileSync(stateFile, [...prevStates].map(([k, v]) => `${k}=${v}`).join("\n"))

        switch (liveState) {
          case "idle":
            if (prev === "working") {
              console.log(`ALERT PHASE_COMPLETE ${name} phase=${feat.phase}`)
              if (feat.mode === "phased" && ["brainstorm", "plan", "review", "simplify"].includes(feat.phase)) {
                console.log(`AUTO_ADVANCING ${name} from ${feat.phase}`)
                try {
                  await $`fleet advance ${name}`.quiet()
                } catch { console.log(`ADVANCE_FAILED ${name}`) }
              } else {
                console.log(`ALERT NEEDS_ADVANCE ${name} phase=${feat.phase} (waiting for user)`)
              }
            }
            break
          case "picker":
            console.log(`ALERT PICKER ${name} phase=${feat.phase} (needs option selection — use 'fleet pick ${name} <N>')`)
            if (feat.status !== "blocked") updateFeature(name, { status: "blocked" })
            break
          case "blocked":
            console.log(`ALERT BLOCKED ${name} phase=${feat.phase} (needs user input)`)
            if (feat.status !== "blocked") updateFeature(name, { status: "blocked" })
            break
          case "working":
            if (feat.status === "blocked") {
              updateFeature(name, { status: "active" })
              console.log(`ALERT UNBLOCKED ${name} (user answered, back to work)`)
            }
            break
          default:
            if (liveState.startsWith("crashed") || liveState === "gone") {
              console.log(`ALERT ${liveState === "gone" ? "SESSION_GONE" : "CRASHED"} ${name} phase=${feat.phase}`)
              updateFeature(name, { status: "crashed" })
              logEvent(name, "crashed", { phase: feat.phase })
            }
        }
      }

      // Check PRs for features in pr_monitoring phase
      const prFeatures = Object.entries(reg.features).filter(([, f]) => f.phase === "pr_monitoring" && f.pr)
      for (const [name, feat] of prFeatures) {
        const prJson = (await $`gh pr view ${feat.pr!.number} --repo ${feat.repo} --json state,statusCheckRollup`.quiet().nothrow()).text()
        try {
          const pr = JSON.parse(prJson)
          if (pr.state === "MERGED") {
            console.log(`ALERT PR_MERGED ${name} PR #${feat.pr!.number}`)
            updateFeature(name, { status: "done", phase: "done" })
            logEvent(name, "done")
          } else if (pr.state === "CLOSED") {
            console.log(`ALERT PR_CLOSED ${name} PR #${feat.pr!.number}`)
          }

          const checks = pr.statusCheckRollup ?? []
          const failing = checks.some((c: any) => c.conclusion === "FAILURE")
          const allPassing = checks.length > 0 && checks.every((c: any) => c.conclusion === "SUCCESS")
          const ciStatus = failing ? "failing" : allPassing ? "passing" : "pending"
          const prevCi = feat.pr!.ciStatus

          if (failing && prevCi !== "failing") console.log(`ALERT CI_FAILED ${name} PR #${feat.pr!.number}`)
          if (allPassing && prevCi !== "passing") console.log(`ALERT CI_PASSED ${name} PR #${feat.pr!.number} — ready to merge`)

          updateFeature(name, { pr: { ...feat.pr!, ciStatus, lastChecked: ts() } })
        } catch {}
      }

      await Bun.sleep(interval)
    }
  })

fleet.command("desc")
  .description("Update feature description (and picker label)")
  .argument("<name>", "Feature name")
  .argument("<text...>", "New description")
  .action(async (name, text) => {
    const feat = requireFeature(name)
    const desc = text.join(" ")
    await $`tmux set-option -t ${feat.tmuxSession} @claude_task ${desc}`.quiet().nothrow()
    updateFeature(name, { description: desc })
    console.log(`DESC_UPDATED: ${name} -> ${desc}`)
  })

const reposCmd = fleet.command("repos")
  .description("Manage repo shortname index")

reposCmd.command("list")
  .description("List all indexed repos")
  .action(() => {
    const repos = readRepos()
    console.log("REPOS:")
    for (const [key, val] of Object.entries(repos)) {
      console.log(`  ${key}\t${val}`)
    }
  })

reposCmd.command("add")
  .description("Add a repo to the index")
  .argument("[path]", "Path to repo", ".")
  .action((path) => {
    const resolved = resolve(path)
    const repos = readRepos()
    repos[basename(resolved)] = resolved
    writeRepos(repos)
    console.log(`ADDED: ${basename(resolved)} -> ${resolved}`)
  })

reposCmd.command("rm")
  .description("Remove a repo from the index")
  .argument("<name>", "Repo shortname to remove")
  .action((name) => {
    const repos = readRepos()
    delete repos[name]
    writeRepos(repos)
    console.log(`REMOVED: ${name}`)
  })

fleet.parse()
