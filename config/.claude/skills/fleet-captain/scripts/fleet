#!/usr/bin/env bun
import { Command } from "commander"
import { $ } from "bun"
import { readFileSync, writeFileSync, existsSync, mkdirSync, appendFileSync, renameSync, readdirSync, rmSync } from "fs"
import { join, basename, resolve } from "path"
import { homedir } from "os"

const FMT_CMD = "#{pane_current_command}"
const FMT_DEAD = "#{pane_dead}"
const FMT_DEAD_STATUS = "#{pane_dead_status}"
const FMT_SESSION_ID = "#{session_id}"
const FMT_SESSIONS = "#{session_id} #{session_name}"

const HOME = homedir()
const FLEET_DIR = join(HOME, ".claude", "fleet")
const REGISTRY = join(FLEET_DIR, "registry.json")
const EVENTS = join(FLEET_DIR, "events.jsonl")
const REPOS = join(FLEET_DIR, "repos.json")

mkdirSync(FLEET_DIR, { recursive: true })
if (!existsSync(REGISTRY)) writeFileSync(REGISTRY, JSON.stringify({ version: 1, updated: "", features: {} }))
if (!existsSync(EVENTS)) writeFileSync(EVENTS, "")
if (!existsSync(REPOS)) writeFileSync(REPOS, "{}")

const ts = () => new Date().toISOString()

function readRegistry(): Registry {
  return JSON.parse(readFileSync(REGISTRY, "utf-8"))
}

function writeRegistry(reg: Registry) {
  const tmp = `${REGISTRY}.tmp`
  writeFileSync(tmp, JSON.stringify(reg, null, 2))
  renameSync(tmp, REGISTRY)
}

function updateFeature(name: string, updates: Partial<Feature>) {
  const reg = readRegistry()
  if (!reg.features[name]) return
  Object.assign(reg.features[name], updates, { updatedAt: ts() })
  reg.updated = ts()
  writeRegistry(reg)
}

function getFeature(name: string): Feature | null {
  return readRegistry().features[name] ?? null
}

function requireFeature(name: string): Feature {
  const feat = getFeature(name)
  if (!feat) {
    console.error(`ERROR: Feature '${name}' not found`)
    process.exit(1)
  }
  return feat
}

function logEvent(feature: string, event: string, extra: Record<string, unknown> = {}) {
  const entry = JSON.stringify({ ts: ts(), feature, event, ...extra })
  appendFileSync(EVENTS, entry + "\n")
}

function readRepos(): Record<string, string> {
  return JSON.parse(readFileSync(REPOS, "utf-8"))
}

function writeRepos(repos: Record<string, string>) {
  writeFileSync(REPOS, JSON.stringify(repos, null, 2))
}

function resolveRepo(input: string): string | null {
  const expanded = input.replace(/^~/, HOME)
  if (existsSync(expanded)) return resolve(expanded)

  const repos = readRepos()
  if (repos[input] && existsSync(repos[input])) return repos[input]

  const fuzzy = Object.entries(repos).find(([k]) => k.includes(input))
  if (fuzzy && existsSync(fuzzy[1])) return fuzzy[1]

  return null
}

async function tmuxGet(target: string, fmt: string): Promise<string> {
  return (await $`tmux display-message -t ${target} -p ${fmt}`.quiet().nothrow()).text().trim()
}

async function tmuxSend(session: string, text: string) {
  await $`tmux send-keys -t ${session}:claude C-u`.quiet()
  await $`tmux send-keys -t ${session}:claude -l ${text}`.quiet()
  await Bun.sleep(1000)
  await $`tmux send-keys -t ${session}:claude Enter`.quiet()
}

async function sessionExists(target: string): Promise<boolean> {
  const result = await $`tmux has-session -t ${target}`.quiet().nothrow()
  return result.exitCode === 0
}

async function waitForReady(session: string, maxWait = 120): Promise<boolean> {
  const target = `${session}:claude`
  for (let elapsed = 0; elapsed < maxWait; elapsed += 2) {
    const cmd = await tmuxGet(target, FMT_CMD)
    if (cmd === "claude") {
      const content = (await $`tmux capture-pane -t ${target} -p -S -5`.quiet().nothrow()).text()
      const hasPrompt = content.includes("❯")
      const hasSpinner = /ctrl.c to interrupt|tokens/.test(content)
      if (hasPrompt && !hasSpinner) {
        await Bun.sleep(2000)
        return true
      }
    }
    await Bun.sleep(2000)
  }
  return false
}

async function checkSessionState(target: string): Promise<string> {
  if (!await sessionExists(target)) return "gone"

  const cmd = await tmuxGet(target, FMT_CMD)

  if (cmd !== "claude") {
    const dead = await tmuxGet(target, FMT_DEAD)
    if (dead === "1") {
      const code = await tmuxGet(target, FMT_DEAD_STATUS)
      return code === "0" ? "exited" : `crashed:${code}`
    }
    return "exited"
  }

  const title = await tmuxGet(target, "#{pane_title}")

  if (title.startsWith("✳")) {
    const lines = (await $`tmux capture-pane -t ${target} -p`.quiet().nothrow()).text().split("\n")
    const lastNonEmpty = lines.findLastIndex(l => l.trim() !== "")
    const content = lines.slice(Math.max(0, lastNonEmpty - 4), lastNonEmpty + 1).join("\n")
    if (/\[y\/n\]|\[Y\/n\]|\[yes\/no\]/.test(content)) return "blocked"
    if (/Enter to select|Space to select|to confirm|to navigate/.test(content)) return "picker"
    return "idle"
  }

  return "working"
}

interface Feature {
  description: string
  repo: string
  worktreePath: string | null
  branch: string | null
  tmuxSession: string
  tmuxSessionId: string
  pr: { number: number; url?: string; ciStatus: string; lastChecked: string } | null
  status: string
  startedAt: string
  updatedAt: string
}

interface Registry {
  version: number
  updated: string
  features: Record<string, Feature>
}

const fleet = new Command("fleet")
  .description("Manage concurrent Claude Code feature sessions")
  .version("1.0.0")

fleet.command("spawn")
  .description("Create a new feature session")
  .argument("<name>", "Feature name (kebab-case)")
  .argument("<repo>", "Repository path or shortname from repos index")
  .argument("[description]", "Prompt to send to the session")
  .option("--worktree", "Create a git worktree for isolation")
  .option("--branch <branch>", "Check out an existing branch")
  .action(async (name, repoInput, description, opts) => {
    const repo = resolveRepo(repoInput)
    if (!repo) {
      console.error(`ERROR: '${repoInput}' is not a directory and not in repos index. Run 'fleet repos list' to see known repos.`)
      process.exit(1)
    }

    const isGit = await $`git -C ${repo} rev-parse --git-dir`.quiet().nothrow()
    if (isGit.exitCode !== 0) {
      console.error(`ERROR: ${repo} is not a git repository`)
      process.exit(1)
    }

    const repos = readRepos()
    repos[basename(repo)] = repo
    writeRepos(repos)

    const existing = getFeature(name)
    if (existing && (existing.status === "active" || existing.status === "blocked")) {
      console.error(`ERROR: Feature '${name}' already exists with status '${existing.status}'`)
      process.exit(1)
    }

    let sessionName = name
    let n = 2
    while (await sessionExists(sessionName)) {
      sessionName = `${name}-${n++}`
    }

    let workDir = repo
    let worktreePath: string | null = null
    let branch: string | null = opts.branch ?? null

    if (opts.worktree) {
      worktreePath = join(repo, ".claude", "worktrees", name)
      branch = branch ?? `worktree-${name}`

      if (existsSync(worktreePath)) {
        console.log(`WORKTREE_EXISTS: ${worktreePath}`)
      } else {
        let defaultBranch = (await $`git -C ${repo} symbolic-ref refs/remotes/origin/HEAD`.quiet().nothrow()).text().trim().replace("refs/remotes/origin/", "")
        if (!defaultBranch) defaultBranch = "main"
        await $`git -C ${repo} fetch origin ${defaultBranch} --quiet`.quiet().nothrow()
        mkdirSync(join(repo, ".claude", "worktrees"), { recursive: true })
        const wt = await $`git -C ${repo} worktree add -b ${branch} ${worktreePath} origin/${defaultBranch}`.nothrow()
        console.log(wt.text())
        console.log(`WORKTREE_CREATED: ${worktreePath} (branch: ${branch})`)
      }
      workDir = worktreePath
    }

    await $`tmux new-session -d -s ${sessionName} -n claude -c ${workDir}`.quiet()
    await $`tmux set-option -t ${sessionName} @fleet_managed 1`.quiet()
    if (description) await $`tmux set-option -t ${sessionName} @claude_task ${description}`.quiet()

    await $`tmux new-window -d -t ${sessionName}:2 -n util -c ${repo}`.quiet().nothrow()
    await $`tmux split-window -d -v -t ${sessionName}:2 -c ${repo}`.quiet().nothrow()
    await $`tmux set-option -w -t ${sessionName}:2 monitor-activity off`.quiet().nothrow()
    await $`tmux select-window -t ${sessionName}:1`.quiet().nothrow()

    const sessionId = await tmuxGet(sessionName, FMT_SESSION_ID)
    console.log(`SESSION_CREATED: ${sessionName} (id: ${sessionId})`)

    await tmuxSend(sessionName, "claude --dangerously-skip-permissions")

    console.log("WAITING_FOR_CLAUDE...")
    if (!await waitForReady(sessionName, 120)) {
      console.error(`ERROR: Claude did not become ready within 120s`)
      console.error(`SESSION: ${sessionName} (you can attach manually)`)
      process.exit(1)
    }
    console.log("CLAUDE_READY")

    if (description) {
      await tmuxSend(sessionName, description)
      console.log(`PROMPT_SENT: ${description}`)
    }

    const reg = readRegistry()
    reg.features[name] = {
      description: description ?? "",
      repo,
      worktreePath,
      branch,
      tmuxSession: sessionName,
      tmuxSessionId: sessionId,
      pr: null,
      status: "active",
      startedAt: ts(),
      updatedAt: ts(),
    }
    reg.updated = ts()
    writeRegistry(reg)
    logEvent(name, "spawned")
    console.log(`REGISTERED: ${name}`)
  })

fleet.command("status")
  .description("Snapshot of all active features with live state and pane content")
  .action(async () => {
    const reg = readRegistry()
    const active = Object.entries(reg.features).filter(([, f]) => f.status !== "done" && f.status !== "abandoned")

    if (active.length === 0) {
      console.log("NO_ACTIVE_FEATURES")
      return
    }

    for (const [name, feat] of active) {
      const liveState = await checkSessionState(feat.tmuxSession)
      const repoName = basename(feat.repo)

      console.log(`--- ${name} ---`)
      console.log(`live=${liveState} repo=${repoName}`)

      if (feat.pr) {
        const prUrl = feat.pr.url ?? (await $`gh pr view ${feat.pr.number} --repo ${feat.repo} --json url -q .url`.quiet().nothrow()).text().trim()
        console.log(`pr=#${feat.pr.number} ci=${feat.pr.ciStatus ?? "unknown"} url=${prUrl}`)
      }

      if (["idle", "blocked", "picker"].includes(liveState)) {
        const content = (await $`tmux capture-pane -t ${feat.tmuxSession}:claude -p -S -20`.quiet().nothrow()).text().trim()
        if (content) {
          console.log("pane:")
          console.log(content)
        }
      }

      console.log("")
    }

    const offsetFile = join(FLEET_DIR, ".events_offset")
    const eventsContent = readFileSync(EVENTS, "utf-8")
    const currentSize = Buffer.byteLength(eventsContent)
    const lastOffset = existsSync(offsetFile) ? parseInt(readFileSync(offsetFile, "utf-8")) || 0 : 0

    if (currentSize > lastOffset) {
      const newLines = Buffer.from(eventsContent).subarray(lastOffset).toString().split("\n").filter(Boolean)
      writeFileSync(offsetFile, String(currentSize))

      if (newLines.length > 0) {
        console.log("--- events ---")
        for (const line of newLines) {
          try {
            const e = JSON.parse(line)
            console.log(`  ${e.feature}: ${e.event}${e.url ? " " + e.url : ""}${e.branch ? " " + e.branch : ""}`)
          } catch {
            console.log(`  ${line}`)
          }
        }
        console.log("")
      }
    }
  })

fleet.command("check")
  .description("Detailed state of one feature")
  .argument("<name>", "Feature name")
  .action(async (name) => {
    const feat = requireFeature(name)
    const state = await checkSessionState(feat.tmuxSession)
    console.log(`FEATURE=${name} STATE=${state}`)

    if (["idle", "working", "blocked", "picker"].includes(state)) {
      console.log("PANE_OUTPUT:")
      const content = (await $`tmux capture-pane -t ${feat.tmuxSessionId} -p -S -5`.quiet().nothrow()).text()
      console.log(content)
    }
  })

fleet.command("send")
  .description("Send text to a session (delivered immediately, queued by Claude if busy)")
  .argument("<name>", "Feature name")
  .argument("<command...>", "Command text to send")
  .action(async (name, command) => {
    const feat = requireFeature(name)
    const state = await checkSessionState(feat.tmuxSession)
    if (state === "gone" || state === "exited" || state.startsWith("crashed")) {
      console.error(`ERROR: Session is ${state}. Cannot send command.`)
      process.exit(1)
    }
    if (state === "picker") {
      console.error(`ERROR: Session '${name}' is showing a picker. Sending text would interact with the picker instead of Claude.`)
      console.error(`  Use 'fleet pick ${name} <number>' to select an option`)
      console.error(`  Or 'fleet keys ${name} Escape' to dismiss it first`)
      process.exit(1)
    }
    if (state === "blocked") {
      console.error(`ERROR: Session '${name}' is waiting for confirmation.`)
      console.error(`  Use 'fleet keys ${name} y' or 'fleet keys ${name} n' to respond`)
      process.exit(1)
    }
    const text = command.join(" ")
    await tmuxSend(feat.tmuxSession, text)
    console.log(`SENT (state was ${state}): ${text}`)
  })

fleet.command("pick")
  .description("Select option N in a Claude Code picker")
  .argument("<name>", "Feature name")
  .argument("<number>", "Option number to select")
  .action(async (name, number) => {
    if (!/^\d+$/.test(number)) {
      console.error("ERROR: Choice must be a number (e.g., 1, 2, 3)")
      process.exit(1)
    }
    const feat = requireFeature(name)
    const state = await checkSessionState(feat.tmuxSession)
    if (state !== "picker") {
      console.error(`ERROR: Session is not showing a picker (state: ${state}).`)
      console.error(`  Use 'fleet check ${name}' to see the current pane output.`)
      process.exit(1)
    }
    await $`tmux send-keys -t ${feat.tmuxSession}:claude ${number}`.quiet()
    console.log(`PICKED: option ${number}`)
  })

fleet.command("keys")
  .description("Send raw tmux key names (Down, Enter, Escape, etc.)")
  .argument("<name>", "Feature name")
  .argument("<keys...>", "Key names to send")
  .action(async (name, keys) => {
    const feat = requireFeature(name)
    await $`tmux send-keys -t ${feat.tmuxSession}:claude ${keys}`.quiet()
    console.log(`KEYS_SENT: ${keys.join(" ")}`)
  })

fleet.command("kill")
  .description("Clean up a feature session: session, worktree, branch")
  .argument("<name>", "Feature name")
  .action(async (name) => {
    const feat = requireFeature(name)
    const { tmuxSessionId: sid, tmuxSession: sname, repo, worktreePath, branch } = feat

    let target: string | null = null
    if (await sessionExists(sid)) target = sid
    else if (await sessionExists(sname)) target = sname
    if (target) {
      await $`tmux send-keys -t ${target} C-c`.quiet().nothrow()
      await Bun.sleep(1000)
      await $`tmux send-keys -t ${target} -l /exit`.quiet().nothrow()
      await $`tmux send-keys -t ${target} Enter`.quiet().nothrow()
      await Bun.sleep(2000)
      await $`tmux kill-session -t ${target}`.quiet().nothrow()
      console.log(`SESSION_KILLED: ${sname}`)
    } else {
      console.log(`SESSION_ALREADY_GONE: ${sname}`)
    }

    if (worktreePath && existsSync(worktreePath)) {
      await $`git -C ${repo} worktree remove --force ${worktreePath}`.quiet().nothrow()
      console.log(`WORKTREE_REMOVED: ${worktreePath}`)
    }

    if (branch) {
      const branchExists = await $`git -C ${repo} rev-parse --verify ${branch}`.quiet().nothrow()
      if (branchExists.exitCode === 0) {
        await $`git -C ${repo} branch -D ${branch}`.quiet().nothrow()
        console.log(`BRANCH_DELETED: ${branch}`)
      }
    }

    for (const prefix of ["teams", "tasks"]) {
      const dir = join(HOME, ".claude", prefix)
      if (existsSync(dir)) {
        for (const entry of readdirSync(dir)) {
          if (entry.startsWith("work-")) rmSync(join(dir, entry), { recursive: true, force: true })
        }
      }
    }

    updateFeature(name, { status: "abandoned" })
    logEvent(name, "abandoned")
    console.log(`DONE: ${name} abandoned and cleaned up`)
  })

fleet.command("list")
  .description("List fleet-managed tmux sessions")
  .action(async () => {
    const sessions = (await $`tmux list-sessions -F ${FMT_SESSIONS}`.quiet().nothrow()).text().trim()
    if (!sessions) return

    for (const line of sessions.split("\n")) {
      const [id, sname] = line.split(" ")
      const managed = (await $`tmux show-option -qv -t ${sname} @fleet_managed`.quiet().nothrow()).text().trim()
      if (managed === "1") {
        const cmd = await tmuxGet(sname, FMT_CMD)
        console.log(`ID=${id} NAME=${sname} CMD=${cmd}`)
      }
    }
  })

fleet.command("recover")
  .description("Reconcile registry with live tmux sessions, worktrees, and PRs")
  .action(async () => {
    const reg = readRegistry()
    const active = Object.entries(reg.features).filter(([, f]) => f.status === "active" || f.status === "blocked")

    if (active.length === 0) {
      console.log("NO_FEATURES_TO_RECOVER")
      return
    }

    console.log("RECOVERING:")
    for (const [name, feat] of active) {
      const sessionAlive = await sessionExists(feat.tmuxSessionId)
      const claudeRunning = sessionAlive && (await tmuxGet(feat.tmuxSessionId, FMT_CMD)) === "claude"
      const worktreeExists = feat.worktreePath ? existsSync(feat.worktreePath) : false

      let prStatus = "none"
      if (feat.branch) {
        const prJson = (await $`gh pr list --repo ${feat.repo} --head ${feat.branch} --json number,state --limit 1`.quiet().nothrow()).text().trim()
        try {
          const prs = JSON.parse(prJson || "[]")
          if (prs.length > 0) prStatus = `PR #${prs[0].number} (${prs[0].state})`
        } catch {}
      }

      const recoverStatus = sessionAlive ? "ok" : "crashed"
      if (!sessionAlive) updateFeature(name, { status: "crashed" })

      console.log(`NAME=${name} SESSION=${sessionAlive ? "yes" : "no"} CLAUDE=${claudeRunning ? "yes" : "no"} WORKTREE=${worktreeExists ? "yes" : "no"} PR=${prStatus} STATUS=${recoverStatus}`)
    }
  })

fleet.command("prune")
  .description("Prune events.jsonl to the last N events")
  .option("--keep <n>", "Number of recent events to keep", "50")
  .action((opts) => {
    const keep = parseInt(opts.keep)
    if (!existsSync(EVENTS)) { console.log("No events file"); return }
    const lines = readFileSync(EVENTS, "utf-8").split("\n").filter(Boolean)
    const before = lines.length
    const kept = lines.slice(-keep)
    const content = kept.join("\n") + "\n"
    writeFileSync(EVENTS, content)
    const newSize = Buffer.byteLength(content)
    writeFileSync(join(FLEET_DIR, ".events_offset"), String(newSize))
    console.log(`PRUNED: ${before} -> ${kept.length} events (offset reset to ${newSize})`)
  })

fleet.command("desc")
  .description("Update feature description (and picker label)")
  .argument("<name>", "Feature name")
  .argument("<text...>", "New description")
  .action(async (name, text) => {
    const feat = requireFeature(name)
    const desc = text.join(" ")
    await $`tmux set-option -t ${feat.tmuxSession} @claude_task ${desc}`.quiet().nothrow()
    updateFeature(name, { description: desc })
    console.log(`DESC_UPDATED: ${name} -> ${desc}`)
  })

const reposCmd = fleet.command("repos")
  .description("Manage repo shortname index")

reposCmd.command("list")
  .description("List all indexed repos")
  .action(() => {
    const repos = readRepos()
    console.log("REPOS:")
    for (const [key, val] of Object.entries(repos)) {
      console.log(`  ${key}\t${val}`)
    }
  })

reposCmd.command("add")
  .description("Add a repo to the index")
  .argument("[path]", "Path to repo", ".")
  .action((path) => {
    const resolved = resolve(path)
    const repos = readRepos()
    repos[basename(resolved)] = resolved
    writeRepos(repos)
    console.log(`ADDED: ${basename(resolved)} -> ${resolved}`)
  })

reposCmd.command("rm")
  .description("Remove a repo from the index")
  .argument("<name>", "Repo shortname to remove")
  .action((name) => {
    const repos = readRepos()
    delete repos[name]
    writeRepos(repos)
    console.log(`REMOVED: ${name}`)
  })

fleet.parse()
