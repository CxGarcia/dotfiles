#!/usr/bin/env bun
import { Command } from "commander"
import { $ } from "bun"
import { readFileSync, writeFileSync, existsSync, mkdirSync, appendFileSync, renameSync, readdirSync, rmSync, symlinkSync, lstatSync, readlinkSync, unlinkSync, realpathSync } from "fs"
import { createInterface } from "readline"
import { join, basename, resolve } from "path"
import { homedir } from "os"

const FMT_CMD = "#{pane_current_command}"
const FMT_DEAD = "#{pane_dead}"
const FMT_DEAD_STATUS = "#{pane_dead_status}"
const FMT_SESSION_ID = "#{session_id}"
const FMT_SESSIONS = "#{session_id} #{session_name}"
const SEP = "\x1f"
const FMT_STATE = `#{pane_current_command}${SEP}#{pane_dead}${SEP}#{pane_dead_status}${SEP}#{pane_title}`

const HOME = homedir()
const FLEET_DIR = join(HOME, ".claude", "fleet")
const REGISTRY = join(FLEET_DIR, "registry.json")
const EVENTS = join(FLEET_DIR, "events.jsonl")
const REPOS = join(FLEET_DIR, "repos.json")
const PR_CACHE = join(FLEET_DIR, ".pr_cache.json")
const PR_CACHE_TTL = 300_000

mkdirSync(FLEET_DIR, { recursive: true })
if (!existsSync(REGISTRY)) writeFileSync(REGISTRY, JSON.stringify({ version: 1, updated: "", features: {} }))
if (!existsSync(EVENTS)) writeFileSync(EVENTS, "")
if (!existsSync(REPOS)) writeFileSync(REPOS, "{}")

const ts = () => new Date().toISOString()

function readRegistry(): Registry {
  return JSON.parse(readFileSync(REGISTRY, "utf-8"))
}

function writeRegistry(reg: Registry) {
  const tmp = `${REGISTRY}.tmp`
  writeFileSync(tmp, JSON.stringify(reg, null, 2))
  renameSync(tmp, REGISTRY)
}

function updateFeature(name: string, updates: Partial<Feature>) {
  const reg = readRegistry()
  if (!reg.features[name]) return
  Object.assign(reg.features[name], updates, { updatedAt: ts() })
  reg.updated = ts()
  writeRegistry(reg)
}

function getFeature(name: string): Feature | null {
  return readRegistry().features[name] ?? null
}

function requireFeature(name: string): Feature {
  const feat = getFeature(name)
  if (!feat) {
    console.error(`ERROR: Feature '${name}' not found`)
    process.exit(1)
  }
  return feat
}

function logEvent(feature: string, event: string, extra: Record<string, unknown> = {}) {
  const entry = JSON.stringify({ ts: ts(), feature, event, ...extra })
  appendFileSync(EVENTS, entry + "\n")
}

async function confirm(message: string): Promise<boolean> {
  const rl = createInterface({ input: process.stdin, output: process.stdout })
  return new Promise((resolve) => {
    rl.question(`${message} [y/N] `, (answer) => {
      rl.close()
      resolve(answer.toLowerCase() === "y")
    })
  })
}

function activeFeatures(): [string, Feature][] {
  const reg = readRegistry()
  return Object.entries(reg.features).filter(([, f]) => f.status !== "done" && f.status !== "abandoned")
}

async function killFeature(name: string) {
  const feat = getFeature(name)
  if (!feat) {
    console.log(`SKIP: Feature '${name}' not found`)
    return
  }
  const { tmuxSessionId: sid, tmuxSession: sname, repo, worktreePath, branch } = feat

  let target: string | null = null
  if (await sessionExists(sid)) target = sid
  else if (await sessionExists(sname)) target = sname
  if (target) {
    await $`tmux send-keys -t ${target} C-c`.quiet().nothrow()
    await Bun.sleep(1000)
    await $`tmux send-keys -t ${target} -l /exit`.quiet().nothrow()
    await $`tmux send-keys -t ${target} Enter`.quiet().nothrow()
    await Bun.sleep(2000)
    await $`tmux kill-session -t ${target}`.quiet().nothrow()
    console.log(`SESSION_KILLED: ${sname}`)
  } else {
    console.log(`SESSION_ALREADY_GONE: ${sname}`)
  }

  if (worktreePath && existsSync(worktreePath)) {
    await $`git -C ${repo} worktree remove --force ${worktreePath}`.quiet().nothrow()
    console.log(`WORKTREE_REMOVED: ${worktreePath}`)
  }

  if (branch) {
    const protectedBranches = new Set(["main", "master", "develop", "staging", "production"])
    if (protectedBranches.has(branch)) {
      console.log(`BRANCH_PROTECTED: ${branch} (not deleted)`)
    } else {
      const branchExists = await $`git -C ${repo} rev-parse --verify ${branch}`.quiet().nothrow()
      if (branchExists.exitCode === 0) {
        await $`git -C ${repo} branch -D ${branch}`.quiet().nothrow()
        console.log(`BRANCH_DELETED: ${branch}`)
      }
    }
  }

  for (const prefix of ["teams", "tasks"]) {
    const dir = join(HOME, ".claude", prefix)
    if (existsSync(dir)) {
      for (const entry of readdirSync(dir)) {
        if (entry.startsWith("work-")) rmSync(join(dir, entry), { recursive: true, force: true })
      }
    }
  }

  updateFeature(name, { status: "abandoned" })
  logEvent(name, "abandoned")
  console.log(`DONE: ${name} abandoned and cleaned up`)
}

function readRepos(): Record<string, string> {
  return JSON.parse(readFileSync(REPOS, "utf-8"))
}

function writeRepos(repos: Record<string, string>) {
  writeFileSync(REPOS, JSON.stringify(repos, null, 2))
}

function resolveRepo(input: string): string | null {
  const expanded = input.replace(/^~/, HOME)
  if (existsSync(expanded)) return resolve(expanded)

  const repos = readRepos()
  if (repos[input] && existsSync(repos[input])) return repos[input]

  const fuzzy = Object.entries(repos).find(([k]) => k.includes(input))
  if (fuzzy && existsSync(fuzzy[1])) return fuzzy[1]

  return null
}

async function tmuxGet(target: string, fmt: string): Promise<string> {
  return (await $`tmux display-message -t ${target} -p ${fmt}`.quiet().nothrow()).text().trim()
}

async function waitForPaneContent(target: string, pattern: string, maxWait = 10): Promise<boolean> {
  const fmt = `#{C/r:${pattern}}`
  for (let elapsed = 0; elapsed < maxWait * 1000; elapsed += 200) {
    const line = (await $`tmux display-message -t ${target} -p ${fmt}`.quiet().nothrow()).text().trim()
    if (line !== "0") return true
    await Bun.sleep(200)
  }
  return false
}

async function tmuxSend(session: string, text: string) {
  const target = `${session}:claude`
  await $`tmux send-keys -t ${target} C-u`.quiet()
  await $`tmux send-keys -t ${target} -l ${text}`.quiet()
  const probe = text.slice(0, 40).replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
  await waitForPaneContent(target, probe, 10)
  await $`tmux send-keys -t ${target} Enter`.quiet()
}

async function sessionExists(target: string): Promise<boolean> {
  const result = await $`tmux has-session -t ${target}`.quiet().nothrow()
  return result.exitCode === 0
}

async function waitForReady(session: string, maxWait = 120): Promise<boolean> {
  const target = `${session}:claude`
  for (let elapsed = 0; elapsed < maxWait * 1000; elapsed += 500) {
    const cmd = await tmuxGet(target, FMT_CMD)
    if (cmd === "claude") {
      const title = await tmuxGet(target, "#{pane_title}")
      if (title.startsWith("✳")) return true
      const content = (await $`tmux capture-pane -t ${target} -p -S -5`.quiet().nothrow()).text()
      const hasPrompt = content.includes("❯")
      const hasSpinner = /ctrl.c to interrupt|tokens/.test(content)
      if (hasPrompt && !hasSpinner) return true
    }
    await Bun.sleep(500)
  }
  return false
}

async function checkSessionState(target: string, captureLines = 5): Promise<{ state: string; content: string | null }> {
  const result = await $`tmux display-message -t ${target} -p ${FMT_STATE}`.quiet().nothrow()
  if (result.exitCode !== 0) return { state: "gone", content: null }

  const [cmd, dead, deadStatus, title] = result.text().trim().split(SEP)

  if (cmd !== "claude") {
    if (dead === "1") {
      return { state: deadStatus === "0" ? "exited" : `crashed:${deadStatus}`, content: null }
    }
    return { state: "exited", content: null }
  }

  if (title.startsWith("✳")) {
    const lines = (await $`tmux capture-pane -t ${target} -p`.quiet().nothrow()).text().split("\n")
    const lastNonEmpty = lines.findLastIndex(l => l.trim() !== "")
    const content = lines.slice(Math.max(0, lastNonEmpty - (captureLines - 1)), lastNonEmpty + 1).join("\n")
    const stateContent = lines.slice(Math.max(0, lastNonEmpty - 4), lastNonEmpty + 1).join("\n")
    if (/\[y\/n\]|\[Y\/n\]|\[yes\/no\]/.test(stateContent)) return { state: "blocked", content }
    if (/Enter to select|Space to select|to confirm|to navigate/.test(stateContent)) return { state: "picker", content }
    return { state: "idle", content }
  }

  return { state: "working", content: null }
}

interface Feature {
  description: string
  title: string
  repo: string
  worktreePath: string | null
  branch: string | null
  tmuxSession: string
  tmuxSessionId: string
  pr: { number: number; url?: string; ciStatus: string; lastChecked: string } | null
  scope: string | null
  tags: string[]
  status: string
  startedAt: string
  updatedAt: string
}

function generateTitle(prompt: string): string {
  let text = prompt
    .replace(/^\/[\w:-]+\s*/, '')
    .split(/[.\n]/)[0]
    .trim()
  text = text.replace(/^(please|can you|could you|i want to|i need to|let's|we need to|we should)\s+/i, '')
  if (text.length > 60) {
    text = text.substring(0, 60).replace(/\s+\S*$/, '')
  }
  if (text.length > 0) {
    text = text.charAt(0).toUpperCase() + text.slice(1)
  }
  return text || prompt.substring(0, 60)
}

function generateTags(prompt: string): string[] {
  const text = prompt.replace(/^\/[\w:-]+\s*/, '').toLowerCase()
    .replace(/n't|'re|'ll|'ve|'s|'d/g, '')
  const stopWords = new Set([
    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
    'of', 'with', 'by', 'from', 'is', 'are', 'was', 'were', 'be', 'been',
    'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',
    'could', 'should', 'may', 'might', 'can', 'this', 'that', 'these',
    'those', 'it', 'its', 'i', 'we', 'you', 'they', 'he', 'she', 'my',
    'our', 'your', 'their', 'not', 'no', 'so', 'if', 'then', 'than',
    'when', 'how', 'what', 'which', 'who', 'all', 'each', 'every', 'both',
    'few', 'more', 'most', 'other', 'some', 'such', 'only', 'just', 'also',
    'very', 'please', 'need', 'want', 'let', 'make', 'run', 'use', 'get',
    'set', 'put', 'take', 'see', 'new', 'first', 'last', 'up', 'out',
    'as', 'about', 'into', 'through', 'after', 'before', 'any', 'here',
    'there', 'where', 'why', 'now', 'like', 'using', 'implement',
    'create', 'add', 'update', 'check', 'look', 'ensure', 'file', 'code',
    'read', 'write', 'docs', 'plan', 'plans', 'full', 'follow', 'step',
    'steps', 'below', 'above', 'section', 'part', 'based', 'start',
  ])
  const words = text
    .replace(/[\w.-]+\.\w{2,4}/g, '')
    .match(/[a-z][a-z0-9-]+/g) ?? []
  return [...new Set(words.filter(w => w.length >= 3 && w.length <= 20 && !stopWords.has(w)))].slice(0, 8)
}

interface PrCacheEntry {
  number: number | null
  checkedAt: string
}

function readPrCache(): Record<string, PrCacheEntry> {
  if (!existsSync(PR_CACHE)) return {}
  try { return JSON.parse(readFileSync(PR_CACHE, "utf-8")) } catch { return {} }
}

function writePrCache(cache: Record<string, PrCacheEntry>) {
  writeFileSync(PR_CACHE, JSON.stringify(cache, null, 2))
}

async function resolveFeatureBranch(feat: Feature): Promise<string> {
  if (feat.branch) return feat.branch
  const workDir = feat.worktreePath && existsSync(feat.worktreePath) ? feat.worktreePath : feat.repo
  return (await $`git -C ${workDir} branch --show-current`.quiet().nothrow()).text().trim() || "—"
}

async function resolveFeaturePrDisplay(name: string, feat: Feature, prCache?: Record<string, PrCacheEntry>): Promise<{ pr: string; ci: string; discoveredPrNumber?: number }> {
  if (feat.pr?.number) {
    const ci = feat.pr.ciStatus && feat.pr.ciStatus !== "unknown" ? feat.pr.ciStatus : "—"
    return { pr: `#${feat.pr.number}`, ci }
  }

  if (!feat.branch) return { pr: "—", ci: "—" }

  const cache = prCache ?? readPrCache()
  const cacheKey = `${feat.repo}:${feat.branch}`
  const cached = cache[cacheKey]
  if (cached && (Date.now() - new Date(cached.checkedAt).getTime()) < PR_CACHE_TTL) {
    if (cached.number) {
      return { pr: `#${cached.number}`, ci: "—", discoveredPrNumber: cached.number }
    }
    return { pr: "—", ci: "—" }
  }

  const result = await $`gh pr view ${feat.branch} --repo ${feat.repo} --json number -q .number`.quiet().nothrow()
  const num = parseInt(result.text().trim())
  const prNumber = isNaN(num) ? null : num

  cache[cacheKey] = { number: prNumber, checkedAt: ts() }
  if (!prCache) writePrCache(cache)

  if (prNumber) {
    return { pr: `#${prNumber}`, ci: "—", discoveredPrNumber: prNumber }
  }

  return { pr: "—", ci: "—" }
}

const STATUS_HEADER = "Name\tState\tRepo\tBranch\tPR\tCI\tTitle"

interface Registry {
  version: number
  updated: string
  features: Record<string, Feature>
}

const fleet = new Command("fleet")
  .description("Manage concurrent Claude Code feature sessions")
  .version("1.0.0")

fleet.command("spawn")
  .description("Create a new feature session")
  .argument("<name>", "Feature name (kebab-case)")
  .argument("<repo>", "Repository path or shortname from repos index")
  .argument("[description]", "Prompt to send to the session")
  .option("--worktree", "Create a git worktree for isolation")
  .option("--branch <branch>", "Check out an existing branch")
  .option("--pr <number>", "Associated PR number")
  .option("--scope <scope>", "Session scope: research, implement, or any")
  .option("--tag <tags>", "Comma-separated tags")
  .option("--title <title>", "Custom title for session picker (auto-generated from prompt if omitted)")
  .action(async (name, repoInput, description, opts) => {
    const repo = resolveRepo(repoInput)
    if (!repo) {
      console.error(`ERROR: '${repoInput}' is not a directory and not in repos index. Run 'fleet repos list' to see known repos.`)
      process.exit(1)
    }

    const isGit = await $`git -C ${repo} rev-parse --git-dir`.quiet().nothrow()
    if (isGit.exitCode !== 0) {
      console.error(`ERROR: ${repo} is not a git repository`)
      process.exit(1)
    }

    const repos = readRepos()
    repos[basename(repo)] = repo
    writeRepos(repos)

    const existing = getFeature(name)
    if (existing && (existing.status === "active" || existing.status === "blocked")) {
      console.error(`ERROR: Feature '${name}' already exists with status '${existing.status}'`)
      process.exit(1)
    }

    let sessionName = name
    let n = 2
    while (await sessionExists(sessionName)) {
      sessionName = `${name}-${n++}`
    }

    let workDir = repo
    let worktreePath: string | null = null
    let branch: string | null = opts.branch ?? null

    if (opts.worktree) {
      worktreePath = join(repo, ".claude", "worktrees", name)
      branch = branch ?? `worktree-${name}`

      if (existsSync(worktreePath)) {
        console.log(`WORKTREE_EXISTS: ${worktreePath}`)
      } else {
        let defaultBranch = (await $`git -C ${repo} symbolic-ref refs/remotes/origin/HEAD`.quiet().nothrow()).text().trim().replace("refs/remotes/origin/", "")
        if (!defaultBranch) defaultBranch = "main"
        await $`git -C ${repo} fetch origin ${defaultBranch} --quiet`.quiet().nothrow()
        if (opts.branch) await $`git -C ${repo} fetch origin ${opts.branch} --quiet`.quiet().nothrow()
        mkdirSync(join(repo, ".claude", "worktrees"), { recursive: true })
        const branchExists = (await $`git -C ${repo} rev-parse --verify ${branch}`.quiet().nothrow()).exitCode === 0
        let wt
        if (branchExists) {
          wt = await $`git -C ${repo} worktree add ${worktreePath} ${branch}`.nothrow()
          console.log(wt.text())
          console.log(`WORKTREE_CREATED: ${worktreePath} (existing branch: ${branch})`)
        } else {
          wt = await $`git -C ${repo} worktree add -b ${branch} ${worktreePath} origin/${defaultBranch}`.nothrow()
          console.log(wt.text())
          console.log(`WORKTREE_CREATED: ${worktreePath} (new branch: ${branch} from origin/${defaultBranch})`)
        }
      }
      workDir = worktreePath
    }

    await $`tmux new-session -d -s ${sessionName} -n claude -c ${workDir}`.quiet()
    await $`tmux set-option -t ${sessionName} @fleet_managed 1`.quiet()
    const title = opts.title ?? (description ? generateTitle(description) : name)
    await $`tmux set-option -t ${sessionName} @claude_task ${title}`.quiet()

    await $`tmux new-window -d -t ${sessionName}:2 -n util -c ${repo}`.quiet().nothrow()
    await $`tmux split-window -d -v -t ${sessionName}:2 -c ${repo}`.quiet().nothrow()
    await $`tmux set-option -w -t ${sessionName}:2 monitor-activity off`.quiet().nothrow()
    await $`tmux select-window -t ${sessionName}:1`.quiet().nothrow()

    const sessionId = await tmuxGet(sessionName, FMT_SESSION_ID)
    console.log(`SESSION_CREATED: ${sessionName} (id: ${sessionId})`)

    await tmuxSend(sessionName, "claude --dangerously-skip-permissions")

    console.log("WAITING_FOR_CLAUDE...")
    if (!await waitForReady(sessionName, 120)) {
      console.error(`ERROR: Claude did not become ready within 120s`)
      console.error(`SESSION: ${sessionName} (you can attach manually)`)
      process.exit(1)
    }
    console.log("CLAUDE_READY")

    if (description) {
      await tmuxSend(sessionName, description)
      console.log(`PROMPT_SENT: ${description}`)
    }

    const reg = readRegistry()
    const pr = opts.pr ? { number: parseInt(opts.pr), ciStatus: "unknown", lastChecked: ts() } : null
    const scope = opts.scope ?? null
    const explicitTags = opts.tag ? opts.tag.split(",").map((t: string) => t.trim()).filter(Boolean) : []
    const autoTags = description ? generateTags(description) : []
    const tags = [...new Set([...explicitTags, ...autoTags])]

    reg.features[name] = {
      description: description ?? "",
      title,
      repo,
      worktreePath,
      branch,
      tmuxSession: sessionName,
      tmuxSessionId: sessionId,
      pr,
      scope,
      tags,
      status: "active",
      startedAt: ts(),
      updatedAt: ts(),
    }
    reg.updated = ts()
    writeRegistry(reg)
    logEvent(name, "spawned")
    console.log(`REGISTERED: ${name} (title: ${title})`)
    if (tags.length > 0) console.log(`TAGS: ${tags.join(", ")}`)
  })

fleet.command("status")
  .description("Snapshot of all active features with live state and pane content")
  .option("--tag <tag>", "Filter by tag")
  .option("--scope <scope>", "Filter by scope (research, implement, any)")
  .action(async (opts) => {
    const reg = readRegistry()
    let active = Object.entries(reg.features).filter(([, f]) => f.status !== "done" && f.status !== "abandoned")

    if (opts.scope) active = active.filter(([, f]) => f.scope === opts.scope)
    if (opts.tag) active = active.filter(([, f]) => f.tags?.includes(opts.tag))

    if (active.length === 0) {
      console.log("NO_ACTIVE_FEATURES")
      return
    }

    const prCache = readPrCache()
    const results = await Promise.allSettled(
      active.map(async ([name, feat]) => {
        const [stateResult, branch, prCi] = await Promise.all([
          checkSessionState(feat.tmuxSession, 20),
          resolveFeatureBranch(feat),
          resolveFeaturePrDisplay(name, feat, prCache),
        ])
        return {
          name, state: stateResult.state, repo: basename(feat.repo), branch,
          pr: prCi.pr, ci: prCi.ci, title: feat.title || name,
          tmuxTarget: `${feat.tmuxSession}:claude`, paneContent: stateResult.content,
          discoveredPrNumber: prCi.discoveredPrNumber,
        }
      })
    )

    const rows = results
      .filter((r): r is PromiseFulfilledResult<{ name: string; state: string; repo: string; branch: string; pr: string; ci: string; title: string; tmuxTarget: string; paneContent: string | null; discoveredPrNumber?: number }> => r.status === "fulfilled")
      .map(r => r.value)

    for (const row of rows) {
      if (row.discoveredPrNumber) {
        updateFeature(row.name, { pr: { number: row.discoveredPrNumber, ciStatus: "unknown", lastChecked: ts() } })
      }
    }
    writePrCache(prCache)

    console.log(STATUS_HEADER)
    for (const row of rows) {
      console.log(`${row.name}\t${row.state}\t${row.repo}\t${row.branch}\t${row.pr}\t${row.ci}\t${row.title}`)
    }

    for (const row of rows) {
      if (["idle", "blocked", "picker"].includes(row.state) && row.paneContent) {
        console.log(`\nPANE:${row.name}`)
        console.log(row.paneContent)
      }
    }

    const offsetFile = join(FLEET_DIR, ".events_offset")
    const eventsContent = readFileSync(EVENTS, "utf-8")
    const currentSize = Buffer.byteLength(eventsContent)
    const lastOffset = existsSync(offsetFile) ? parseInt(readFileSync(offsetFile, "utf-8")) || 0 : 0

    if (currentSize > lastOffset) {
      const newLines = Buffer.from(eventsContent).subarray(lastOffset).toString().split("\n").filter(Boolean)
      writeFileSync(offsetFile, String(currentSize))

      if (newLines.length > 0) {
        console.log("\nEVENTS")
        for (const line of newLines) {
          try {
            const e = JSON.parse(line)
            console.log(`  ${e.feature}: ${e.event}${e.url ? " " + e.url : ""}${e.branch ? " " + e.branch : ""}`)
          } catch {
            console.log(`  ${line}`)
          }
        }
      }
    }
  })

fleet.command("check")
  .description("Detailed state of one feature")
  .argument("<name>", "Feature name")
  .action(async (name) => {
    const feat = requireFeature(name)
    const { state, content: paneContent } = await checkSessionState(feat.tmuxSession, 20)
    const repo = basename(feat.repo)
    const branch = await resolveFeatureBranch(feat)
    const prCi = await resolveFeaturePrDisplay(name, feat)
    const title = feat.title || name
    if (prCi.discoveredPrNumber) {
      updateFeature(name, { pr: { number: prCi.discoveredPrNumber, ciStatus: "unknown", lastChecked: ts() } })
    }

    console.log(STATUS_HEADER)
    console.log(`${name}\t${state}\t${repo}\t${branch}\t${prCi.pr}\t${prCi.ci}\t${title}`)

    if (["idle", "working", "blocked", "picker"].includes(state)) {
      console.log("\nPANE_OUTPUT:")
      const content = paneContent ?? (await $`tmux capture-pane -t ${feat.tmuxSessionId} -p -S -5`.quiet().nothrow()).text()
      console.log(content)
    }
  })

fleet.command("check-active")
  .description("Detailed state of all working/picker/blocked sessions (skips idle/gone/exited)")
  .action(async () => {
    const features = activeFeatures()
    if (features.length === 0) {
      console.log("NO_ACTIVE_FEATURES")
      return
    }

    const prCache = readPrCache()
    const results = await Promise.allSettled(
      features.map(async ([name, feat]) => {
        const [stateResult, branch, prCi] = await Promise.all([
          checkSessionState(feat.tmuxSession, 20),
          resolveFeatureBranch(feat),
          resolveFeaturePrDisplay(name, feat, prCache),
        ])
        return {
          name, state: stateResult.state, repo: basename(feat.repo), branch,
          pr: prCi.pr, ci: prCi.ci, title: feat.title || name,
          tmuxTarget: `${feat.tmuxSession}:claude`, paneContent: stateResult.content,
          discoveredPrNumber: prCi.discoveredPrNumber,
        }
      })
    )

    const allRows = results
      .filter((r): r is PromiseFulfilledResult<{ name: string; state: string; repo: string; branch: string; pr: string; ci: string; title: string; tmuxTarget: string; paneContent: string | null; discoveredPrNumber?: number }> => r.status === "fulfilled")
      .map(r => r.value)

    for (const row of allRows) {
      if (row.discoveredPrNumber) {
        updateFeature(row.name, { pr: { number: row.discoveredPrNumber, ciStatus: "unknown", lastChecked: ts() } })
      }
    }
    writePrCache(prCache)

    const rows = allRows.filter(r => ["working", "picker", "blocked"].includes(r.state))

    if (rows.length === 0) {
      console.log("NO_ACTIVE_SESSIONS (all idle/gone/exited)")
      return
    }

    console.log(STATUS_HEADER)
    for (const row of rows) {
      console.log(`${row.name}\t${row.state}\t${row.repo}\t${row.branch}\t${row.pr}\t${row.ci}\t${row.title}`)
    }

    for (const row of rows) {
      if (row.paneContent) {
        console.log(`\nPANE:${row.name}`)
        console.log(row.paneContent)
      }
    }
  })

interface CiState {
  checks: Record<string, string>
  overallCi: string
  commentCount: number
  reviewCount: number
  mergeable: string
  lastReviewIds: number[]
}

interface CiEvent {
  ts: string
  type: string
  priority: number
  detail: string
}

function ciStateFile(name: string): string {
  return join(FLEET_DIR, `.ci_state_${name}.json`)
}

function readCiState(name: string): CiState | null {
  const path = ciStateFile(name)
  if (!existsSync(path)) return null
  try { return JSON.parse(readFileSync(path, "utf-8")) } catch { return null }
}

function writeCiState(name: string, state: CiState) {
  writeFileSync(ciStateFile(name), JSON.stringify(state, null, 2))
}

const ownerRepoCache = new Map<string, string>()

async function getOwnerRepo(repoPath: string): Promise<string> {
  const cached = ownerRepoCache.get(repoPath)
  if (cached !== undefined) return cached
  const remote = (await $`git -C ${repoPath} remote get-url origin`.quiet().nothrow()).text().trim()
  const match = remote.match(/github\.com[:/](.+?)(?:\.git)?$/)
  const result = match ? match[1] : ""
  ownerRepoCache.set(repoPath, result)
  return result
}

async function resolvePrNumber(feat: Feature): Promise<number | null> {
  if (feat.pr?.number) return feat.pr.number
  if (!feat.branch) return null
  const result = await $`gh pr view ${feat.branch} --repo ${feat.repo} --json number -q .number`.quiet().nothrow()
  const num = parseInt(result.text().trim())
  return isNaN(num) ? null : num
}

async function fetchCiSnapshot(repoPath: string, prNumber: number): Promise<CiState> {
  const ownerRepo = await getOwnerRepo(repoPath)

  const [checksResult, prResult, reviewsResult, commentsResult] = await Promise.all([
    $`gh pr checks ${prNumber} --repo ${ownerRepo} --json name,state`.quiet().nothrow(),
    $`gh api repos/${ownerRepo}/pulls/${prNumber} -q '{mergeable_state: .mergeable_state, mergeable: .mergeable}'`.quiet().nothrow(),
    $`gh api repos/${ownerRepo}/pulls/${prNumber}/reviews -q '[.[] | {id, state}]'`.quiet().nothrow(),
    $`gh api repos/${ownerRepo}/pulls/${prNumber}/comments -q 'length'`.quiet().nothrow(),
  ])

  const checks: Record<string, string> = {}
  let overallCi = "unknown"
  try {
    const parsed = JSON.parse(checksResult.text().trim())
    if (Array.isArray(parsed)) {
      let hasFailure = false
      let hasPending = false
      for (const c of parsed) {
        const status = (c.state ?? "PENDING").toUpperCase()
        if (status === "SKIPPED") continue
        checks[c.name] = status.toLowerCase()
        if (["FAILURE", "CANCELLED", "TIMED_OUT", "ACTION_REQUIRED", "ERROR", "STARTUP_FAILURE"].includes(status)) hasFailure = true
        else if (["PENDING", "QUEUED", "IN_PROGRESS", "WAITING", "REQUESTED", "EXPECTED"].includes(status)) hasPending = true
      }
      overallCi = hasFailure ? "failing" : hasPending ? "pending" : Object.keys(checks).length > 0 ? "passing" : "unknown"
    }
  } catch {}

  let mergeable = "unknown"
  try {
    const pr = JSON.parse(prResult.text().trim())
    mergeable = pr.mergeable_state ?? (pr.mergeable ? "mergeable" : "unknown")
  } catch {}

  let reviewCount = 0
  let lastReviewIds: number[] = []
  try {
    const reviews = JSON.parse(reviewsResult.text().trim())
    reviewCount = reviews.length
    lastReviewIds = reviews.map((r: { id: number }) => r.id)
  } catch {}

  const commentCount = parseInt(commentsResult.text().trim()) || 0

  return { checks, overallCi, commentCount, reviewCount, mergeable, lastReviewIds }
}

function diffCiStates(prev: CiState, curr: CiState): CiEvent[] {
  const events: CiEvent[] = []

  if (prev.overallCi !== curr.overallCi) {
    if (curr.overallCi === "failing") {
      const failed = Object.entries(curr.checks).filter(([, v]) => ["failure", "cancelled", "timed_out"].includes(v)).map(([k]) => k)
      events.push({ ts: ts(), type: "ci_failure", priority: 0, detail: `CI: ${prev.overallCi} → failing (${failed.join(", ")})` })
    } else if (curr.overallCi === "passing") {
      events.push({ ts: ts(), type: "ci_success", priority: 1, detail: `CI: ${prev.overallCi} → passing` })
    } else if (curr.overallCi === "pending") {
      events.push({ ts: ts(), type: "ci_pending", priority: 2, detail: `CI: ${prev.overallCi} → pending` })
    }
  } else {
    for (const [name, status] of Object.entries(curr.checks)) {
      if (prev.checks[name] && prev.checks[name] !== status) {
        const prio = ["failure", "cancelled", "timed_out"].includes(status) ? 0 : status === "success" ? 2 : 2
        events.push({ ts: ts(), type: "check_change", priority: prio, detail: `check ${name}: ${prev.checks[name]} → ${status}` })
      }
    }
  }

  if (prev.mergeable !== curr.mergeable) {
    if (["dirty", "unstable"].includes(curr.mergeable)) {
      events.push({ ts: ts(), type: "merge_conflict", priority: 0, detail: `merge state: ${prev.mergeable} → ${curr.mergeable}` })
    } else {
      events.push({ ts: ts(), type: "merge_state", priority: 2, detail: `merge state: ${prev.mergeable} → ${curr.mergeable}` })
    }
  }

  if (curr.reviewCount > prev.reviewCount) {
    const newCount = curr.reviewCount - prev.reviewCount
    events.push({ ts: ts(), type: "new_reviews", priority: 1, detail: `${newCount} new review(s)` })
  }

  if (curr.commentCount > prev.commentCount) {
    const newCount = curr.commentCount - prev.commentCount
    events.push({ ts: ts(), type: "new_comments", priority: 1, detail: `${newCount} new comment(s)` })
  }

  return events
}

interface WatchEvent {
  ts: string
  feature: string
  type: string
  priority: number
  from?: string
  to?: string
  url?: string
  branch?: string
  message?: string
}

function watchEventPriority(type: string, state?: string): number {
  if (type === "state_change") {
    if (state === "picker" || state === "blocked") return 0
    if (state === "idle" || state === "gone" || state === "exited" || state?.startsWith("crashed")) return 1
    if (state === "working") return 2
    return 3
  }
  switch (type) {
    case "push_failed": return 1
    case "pr_created": return 2
    case "pushed": return 2
    case "committed": return 2
    case "context_warning": return 3
    case "spawned": return 3
    case "abandoned": return 3
    default: return 3
  }
}

fleet.command("watch")
  .description("Block until fleet events occur or timeout expires")
  .option("--timeout <seconds>", "Max wait in seconds", "60")
  .option("--interval <seconds>", "State polling interval in seconds", "3")
  .action(async (opts) => {
    const timeout = parseInt(opts.timeout)
    const interval = parseFloat(opts.interval)
    const features = activeFeatures()

    if (features.length === 0) {
      console.log("WATCH: no active features")
      return
    }

    const snapshot: Record<string, string> = {}
    const initialStates = await Promise.allSettled(
      features.map(async ([name, feat]) => ({ name, state: (await checkSessionState(feat.tmuxSession)).state }))
    )
    for (const r of initialStates) {
      if (r.status === "fulfilled") snapshot[r.value.name] = r.value.state
    }

    const offsetFile = join(FLEET_DIR, ".events_offset")
    let lastOffset = existsSync(offsetFile) ? parseInt(readFileSync(offsetFile, "utf-8")) || 0 : 0

    const startTime = Date.now()
    const collected: WatchEvent[] = []

    function collectFileEvents() {
      if (!existsSync(EVENTS)) return
      const content = readFileSync(EVENTS, "utf-8")
      const currentSize = Buffer.byteLength(content)
      if (currentSize <= lastOffset) return

      const newLines = Buffer.from(content).subarray(lastOffset).toString().split("\n").filter(Boolean)
      for (const line of newLines) {
        try {
          const e = JSON.parse(line)
          collected.push({
            ts: e.ts,
            feature: e.feature,
            type: e.event,
            priority: watchEventPriority(e.event),
            ...(e.url && { url: e.url }),
            ...(e.branch && { branch: e.branch }),
            ...(e.message && { message: e.message }),
          })
        } catch {}
      }
      lastOffset = currentSize
    }

    async function collectStateChanges() {
      const states = await Promise.allSettled(
        features.map(async ([name, feat]) => ({ name, state: (await checkSessionState(feat.tmuxSession)).state }))
      )
      for (const r of states) {
        if (r.status !== "fulfilled") continue
        const { name, state: current } = r.value
        const previous = snapshot[name]
        if (current !== previous) {
          collected.push({
            ts: ts(),
            feature: name,
            type: "state_change",
            from: previous,
            to: current,
            priority: watchEventPriority("state_change", current),
          })
          snapshot[name] = current
        }
      }
    }

    while ((Date.now() - startTime) / 1000 < timeout) {
      collectFileEvents()
      await collectStateChanges()

      if (collected.length > 0) {
        await Bun.sleep(2000)
        collectFileEvents()
        await collectStateChanges()
        break
      }

      await Bun.sleep(interval * 1000)
    }

    writeFileSync(offsetFile, String(lastOffset))
    collected.sort((a, b) => a.priority - b.priority || a.ts.localeCompare(b.ts))

    const elapsed = Math.round((Date.now() - startTime) / 1000)

    if (collected.length === 0) {
      console.log(`WATCH: no events (${elapsed}s)`)
    } else {
      console.log(`WATCH: ${collected.length} event(s) in ${elapsed}s`)

      const actionable = collected.filter(e => e.priority <= 1)
      if (actionable.length > 0) {
        console.log("\n--- needs attention ---")
        for (const e of actionable) {
          if (e.type === "state_change") {
            const hint = e.to === "picker" ? `fleet check ${e.feature}; fleet pick ${e.feature} <N>` :
                         e.to === "blocked" ? `fleet check ${e.feature}; fleet keys ${e.feature} y/n` :
                         e.to === "idle" ? `fleet check ${e.feature}` :
                         e.to === "gone" || e.to === "exited" ? `fleet kill --gone` :
                         e.to?.startsWith("crashed") ? `fleet check ${e.feature}` : ""
            console.log(`  ${e.feature}: ${e.from} → ${e.to}${hint ? ` — ${hint}` : ""}`)
          } else {
            console.log(`  ${e.feature}: ${e.type}`)
          }
        }
      }

      console.log("\n--- events ---")
      for (const e of collected) {
        if (e.type === "state_change") {
          console.log(`  ${e.feature}: ${e.from} → ${e.to}`)
        } else if (e.type === "pr_created") {
          console.log(`  ${e.feature}: PR created ${e.url ?? ""}`)
        } else if (e.type === "pushed") {
          console.log(`  ${e.feature}: pushed ${e.branch ?? ""}`)
        } else if (e.type === "committed") {
          console.log(`  ${e.feature}: committed${e.message ? " " + e.message : ""}`)
        } else if (e.type === "context_warning") {
          console.log(`  ${e.feature}: context compacting`)
        } else {
          console.log(`  ${e.feature}: ${e.type}`)
        }
      }
    }

    console.log("\n--- states ---")
    console.log(Object.entries(snapshot).map(([n, s]) => `${n}=${s}`).join(" "))
  })

fleet.command("pr")
  .description("Monitor PR status: CI checks, reviews, comments, and merge state")
  .argument("<name>", "Feature name")
  .option("--once", "One-shot check, no polling")
  .option("--timeout <seconds>", "Max polling duration in seconds", "120")
  .action(async (name, opts) => {
    const feat = requireFeature(name)
    const prNumber = await resolvePrNumber(feat)
    if (!prNumber) {
      console.error(`ERROR: No PR found for '${name}'. Set one with 'fleet desc ${name} --pr <number>' or push a branch first.`)
      process.exit(1)
    }

    if (!feat.pr) {
      updateFeature(name, { pr: { number: prNumber, ciStatus: "unknown", lastChecked: ts() } })
    }

    const ownerRepo = await getOwnerRepo(feat.repo)
    console.log(`CI: monitoring PR #${prNumber} (${ownerRepo})`)

    if (opts.once) {
      const snapshot = await fetchCiSnapshot(feat.repo, prNumber)
      writeCiState(name, snapshot)
      updateFeature(name, { pr: { number: prNumber, ciStatus: snapshot.overallCi, lastChecked: ts() } })

      console.log(`\n--- CI Status ---`)
      console.log(`overall: ${snapshot.overallCi}`)
      for (const [checkName, status] of Object.entries(snapshot.checks)) {
        const icon = status === "success" ? "+" : ["failure", "cancelled", "timed_out"].includes(status) ? "X" : "~"
        console.log(`  [${icon}] ${checkName}: ${status}`)
      }

      console.log(`\n--- Reviews & Comments ---`)
      console.log(`reviews: ${snapshot.reviewCount}`)
      console.log(`comments: ${snapshot.commentCount}`)

      console.log(`\n--- Merge State ---`)
      console.log(`mergeable: ${snapshot.mergeable}`)

      logEvent(name, "ci_checked", { pr: prNumber, ci: snapshot.overallCi, mergeable: snapshot.mergeable })
      return
    }

    let prev = readCiState(name) ?? await fetchCiSnapshot(feat.repo, prNumber)
    writeCiState(name, prev)

    console.log(`initial: ci=${prev.overallCi} mergeable=${prev.mergeable} reviews=${prev.reviewCount} comments=${prev.commentCount}`)
    console.log(`polling every 15s (timeout ${opts.timeout}s)...\n`)

    const timeout = parseInt(opts.timeout)
    const startTime = Date.now()
    const allEvents: CiEvent[] = []

    while ((Date.now() - startTime) / 1000 < timeout) {
      await Bun.sleep(15000)

      const curr = await fetchCiSnapshot(feat.repo, prNumber)
      const events = diffCiStates(prev, curr)

      if (events.length > 0) {
        for (const e of events) {
          const tag = e.priority === 0 ? "P0" : e.priority === 1 ? "P1" : "P2"
          console.log(`[${tag}] ${e.detail}`)
          allEvents.push(e)
        }
      }

      writeCiState(name, curr)
      updateFeature(name, { pr: { number: prNumber, ciStatus: curr.overallCi, lastChecked: ts() } })
      prev = curr

      if (curr.overallCi === "failing") {
        console.log(`\nCI failed — stopping poll`)
        break
      }
      if (curr.overallCi === "passing" && curr.mergeable === "clean") {
        console.log(`\nCI passing + mergeable — stopping poll`)
        break
      }
    }

    const elapsed = Math.round((Date.now() - startTime) / 1000)
    const p0 = allEvents.filter(e => e.priority === 0)
    const p1 = allEvents.filter(e => e.priority === 1)

    console.log(`\n--- summary (${elapsed}s) ---`)
    console.log(`ci=${prev.overallCi} mergeable=${prev.mergeable} reviews=${prev.reviewCount} comments=${prev.commentCount}`)
    if (p0.length > 0) {
      console.log(`\n--- needs attention ---`)
      for (const e of p0) console.log(`  ${e.detail}`)
    }
    if (p1.length > 0) {
      console.log(`\n--- actionable ---`)
      for (const e of p1) console.log(`  ${e.detail}`)
    }
    if (allEvents.length === 0) console.log(`no changes detected`)

    logEvent(name, "ci_monitored", { pr: prNumber, ci: prev.overallCi, events: allEvents.length, elapsed })
  })

fleet.command("poll")
  .description("Non-blocking check for new events and state changes (used by hooks)")
  .action(async () => {
    const features = activeFeatures()
    if (features.length === 0) return

    const snapshotFile = join(FLEET_DIR, ".state_snapshot")
    let snapshot: Record<string, string> = {}
    if (existsSync(snapshotFile)) {
      try { snapshot = JSON.parse(readFileSync(snapshotFile, "utf-8")) } catch {}
    }

    const offsetFile = join(FLEET_DIR, ".events_offset")
    let lastOffset = existsSync(offsetFile) ? parseInt(readFileSync(offsetFile, "utf-8")) || 0 : 0

    const events: string[] = []

    if (existsSync(EVENTS)) {
      const content = readFileSync(EVENTS, "utf-8")
      const currentSize = Buffer.byteLength(content)
      if (currentSize > lastOffset) {
        const newLines = Buffer.from(content).subarray(lastOffset).toString().split("\n").filter(Boolean)
        const deduped = new Map<string, { event: string; feature: string; url?: string; branch?: string; message?: string }>()
        for (const line of newLines) {
          try {
            const e = JSON.parse(line)
            deduped.set(`${e.feature}:${e.event}`, e)
          } catch {}
        }
        for (const e of deduped.values()) {
          if (e.event === "pr_created") events.push(`  ${e.feature}: PR created ${e.url ?? ""}`)
          else if (e.event === "pushed") events.push(`  ${e.feature}: pushed ${e.branch ?? ""}`)
          else if (e.event === "committed") events.push(`  ${e.feature}: committed`)
          else if (e.event === "context_warning") events.push(`  ${e.feature}: context compacting — may lose coherence`)
          else events.push(`  ${e.feature}: ${e.event}`)
        }
        lastOffset = currentSize
      }
    }

    const newSnapshot: Record<string, string> = {}
    const pollStates = await Promise.allSettled(
      features.map(async ([name, feat]) => ({ name, state: (await checkSessionState(feat.tmuxSession)).state }))
    )
    for (const r of pollStates) {
      if (r.status !== "fulfilled") continue
      const { name, state: current } = r.value
      newSnapshot[name] = current
      const previous = snapshot[name]
      if (previous && previous !== current) {
        const hint = current === "picker" ? ` — fleet pick ${name} <N>` :
                     current === "blocked" ? ` — fleet keys ${name} y/n` :
                     current === "gone" || current === "exited" ? ` — fleet kill --gone` :
                     current?.startsWith("crashed") ? ` — fleet check ${name}` : ""
        events.push(`  ${name}: ${previous} → ${current}${hint}`)
      }
    }

    writeFileSync(offsetFile, String(lastOffset))
    writeFileSync(snapshotFile, JSON.stringify(newSnapshot))

    if (events.length === 0) return

    console.log(`--- Fleet Events (${events.length} new) ---`)
    for (const e of events) console.log(e)
    console.log("--- End Fleet Events ---")
  })

fleet.command("send")
  .description("Send text to a session (delivered immediately, queued by Claude if busy)")
  .argument("<name>", "Feature name")
  .argument("<command...>", "Command text to send")
  .action(async (name, command) => {
    const feat = requireFeature(name)
    const { state } = await checkSessionState(feat.tmuxSession)
    if (state === "gone" || state === "exited" || state.startsWith("crashed")) {
      console.error(`ERROR: Session is ${state}. Cannot send command.`)
      process.exit(1)
    }
    if (state === "picker") {
      console.error(`ERROR: Session '${name}' is showing a picker. Sending text would interact with the picker instead of Claude.`)
      console.error(`  Use 'fleet pick ${name} <number>' to select an option`)
      console.error(`  Or 'fleet keys ${name} Escape' to dismiss it first`)
      process.exit(1)
    }
    if (state === "blocked") {
      console.error(`ERROR: Session '${name}' is waiting for confirmation.`)
      console.error(`  Use 'fleet keys ${name} y' or 'fleet keys ${name} n' to respond`)
      process.exit(1)
    }
    const text = command.join(" ")
    await tmuxSend(feat.tmuxSession, text)
    console.log(`SENT (state was ${state}): ${text}`)
  })

fleet.command("send-multi")
  .description("Send the same message to multiple sessions")
  .argument("<names>", "Comma-separated feature names")
  .argument("<command...>", "Command text to send")
  .action(async (namesStr: string, command: string[]) => {
    const names = namesStr.split(",").map(n => n.trim()).filter(Boolean)
    const text = command.join(" ")

    if (names.length === 0) {
      console.error("ERROR: Provide comma-separated feature names")
      process.exit(1)
    }

    for (const name of names) {
      const feat = getFeature(name)
      if (!feat) {
        console.log(`SKIP: ${name} not found`)
        continue
      }
      const { state } = await checkSessionState(feat.tmuxSession)
      if (["gone", "exited"].includes(state) || state.startsWith("crashed")) {
        console.log(`SKIP: ${name} is ${state}`)
        continue
      }
      if (state === "picker") {
        console.log(`SKIP: ${name} is showing a picker`)
        continue
      }
      if (state === "blocked") {
        console.log(`SKIP: ${name} is waiting for confirmation`)
        continue
      }
      await tmuxSend(feat.tmuxSession, text)
      console.log(`SENT to ${name} (state was ${state}): ${text}`)
    }
  })

fleet.command("pick")
  .description("Select option N in a Claude Code picker")
  .argument("<name>", "Feature name")
  .argument("<number>", "Option number to select")
  .action(async (name, number) => {
    if (!/^\d+$/.test(number)) {
      console.error("ERROR: Choice must be a number (e.g., 1, 2, 3)")
      process.exit(1)
    }
    const feat = requireFeature(name)
    const { state } = await checkSessionState(feat.tmuxSession)
    if (state !== "picker") {
      console.error(`ERROR: Session is not showing a picker (state: ${state}).`)
      console.error(`  Use 'fleet check ${name}' to see the current pane output.`)
      process.exit(1)
    }
    await $`tmux send-keys -t ${feat.tmuxSession}:claude ${number}`.quiet()
    console.log(`PICKED: option ${number}`)
  })

fleet.command("keys")
  .description("Send raw tmux key names (Down, Enter, Escape, etc.)")
  .argument("<name>", "Feature name")
  .argument("<keys...>", "Key names to send")
  .action(async (name, keys) => {
    const feat = requireFeature(name)
    await $`tmux send-keys -t ${feat.tmuxSession}:claude ${keys}`.quiet()
    console.log(`KEYS_SENT: ${keys.join(" ")}`)
  })

fleet.command("kill")
  .description("Kill feature sessions: one, many, or by state (--all, --idle, --gone)")
  .argument("[names...]", "Feature names to kill")
  .option("--all", "Kill all active sessions")
  .option("--idle", "Kill all idle sessions")
  .option("--gone", "Clean up all gone/exited/crashed sessions")
  .option("-y, --yes", "Skip confirmation")
  .action(async (names: string[], opts) => {
    let targets: string[] = []

    if (opts.all) {
      targets = activeFeatures().map(([n]) => n)
    } else if (opts.idle || opts.gone) {
      for (const [name, feat] of activeFeatures()) {
        const { state } = await checkSessionState(feat.tmuxSession)
        if (opts.idle && state === "idle") targets.push(name)
        if (opts.gone && (["gone", "exited"].includes(state) || state.startsWith("crashed"))) targets.push(name)
      }
    } else if (names.length > 0) {
      for (const name of names) requireFeature(name)
      targets = names
    } else {
      console.error("ERROR: Provide feature names, or use --all, --idle, --gone")
      process.exit(1)
    }

    if (targets.length === 0) {
      console.log("NO_MATCHING_SESSIONS")
      return
    }

    console.log(`Will kill ${targets.length} session(s):`)
    for (const name of targets) console.log(`  - ${name}`)

    if (!opts.yes && targets.length > 1) {
      if (!await confirm("\nProceed?")) {
        console.log("CANCELLED")
        return
      }
    }

    for (const name of targets) {
      if (targets.length > 1) console.log(`\n--- killing ${name} ---`)
      await killFeature(name)
    }
  })

fleet.command("list")
  .description("List fleet-managed tmux sessions")
  .action(async () => {
    const fmt = "#{session_id} #{session_name} #{@fleet_managed} #{pane_current_command} #{@claude_task}"
    const sessions = (await $`tmux list-sessions -F ${fmt}`.quiet().nothrow()).text().trim()
    if (!sessions) return

    for (const line of sessions.split("\n")) {
      const [id, sname, managed, cmd, ...taskParts] = line.split(" ")
      if (managed !== "1") continue
      const task = taskParts.join(" ").trim()
      console.log(`ID=${id} NAME=${sname} CMD=${cmd}${task ? " TITLE=" + task : ""}`)
    }
  })

fleet.command("recover")
  .description("Reconcile registry with live tmux sessions, worktrees, and PRs")
  .action(async () => {
    const reg = readRegistry()
    const active = Object.entries(reg.features).filter(([, f]) => f.status === "active" || f.status === "blocked")

    if (active.length === 0) {
      console.log("NO_FEATURES_TO_RECOVER")
      return
    }

    console.log("RECOVERING:")
    for (const [name, feat] of active) {
      const sessionAlive = await sessionExists(feat.tmuxSessionId)
      const claudeRunning = sessionAlive && (await tmuxGet(feat.tmuxSessionId, FMT_CMD)) === "claude"
      const worktreeExists = feat.worktreePath ? existsSync(feat.worktreePath) : false

      let prStatus = "none"
      if (feat.branch) {
        const prJson = (await $`gh pr list --repo ${feat.repo} --head ${feat.branch} --json number,state --limit 1`.quiet().nothrow()).text().trim()
        try {
          const prs = JSON.parse(prJson || "[]")
          if (prs.length > 0) prStatus = `PR #${prs[0].number} (${prs[0].state})`
        } catch {}
      }

      const recoverStatus = sessionAlive ? "ok" : "crashed"
      if (!sessionAlive) updateFeature(name, { status: "crashed" })

      console.log(`NAME=${name} SESSION=${sessionAlive ? "yes" : "no"} CLAUDE=${claudeRunning ? "yes" : "no"} WORKTREE=${worktreeExists ? "yes" : "no"} PR=${prStatus} STATUS=${recoverStatus}`)
    }
  })

fleet.command("prune")
  .description("Prune events.jsonl to the last N events")
  .option("--keep <n>", "Number of recent events to keep", "50")
  .action((opts) => {
    const keep = parseInt(opts.keep)
    if (!existsSync(EVENTS)) { console.log("No events file"); return }
    const lines = readFileSync(EVENTS, "utf-8").split("\n").filter(Boolean)
    const before = lines.length
    const kept = lines.slice(-keep)
    const content = kept.join("\n") + "\n"
    writeFileSync(EVENTS, content)
    const newSize = Buffer.byteLength(content)
    writeFileSync(join(FLEET_DIR, ".events_offset"), String(newSize))
    console.log(`PRUNED: ${before} -> ${kept.length} events (offset reset to ${newSize})`)
  })

fleet.command("desc")
  .description("Update feature description and metadata")
  .argument("<name>", "Feature name")
  .argument("[text...]", "New description")
  .option("--branch <branch>", "Set target branch")
  .option("--pr <number>", "Set associated PR number")
  .option("--scope <scope>", "Set scope: research, implement, or any")
  .option("--tag <tags>", "Set comma-separated tags")
  .option("--title <title>", "Set session title for picker display")
  .action(async (name, text, opts) => {
    const feat = requireFeature(name)
    const updates: Partial<Feature> = {}

    if (text.length > 0) {
      const desc = text.join(" ")
      updates.description = desc
      if (!opts.title) {
        updates.title = generateTitle(desc)
        await $`tmux set-option -t ${feat.tmuxSession} @claude_task ${updates.title}`.quiet().nothrow()
      }
    }

    if (opts.title) {
      updates.title = opts.title
      await $`tmux set-option -t ${feat.tmuxSession} @claude_task ${opts.title}`.quiet().nothrow()
    }

    if (opts.branch) updates.branch = opts.branch
    if (opts.pr) updates.pr = { number: parseInt(opts.pr), ciStatus: feat.pr?.ciStatus ?? "unknown", lastChecked: ts() }
    if (opts.scope) updates.scope = opts.scope
    if (opts.tag) updates.tags = opts.tag.split(",").map((t: string) => t.trim()).filter(Boolean)

    if (Object.keys(updates).length === 0) {
      console.error("ERROR: Provide description text, --title, or metadata flags")
      process.exit(1)
    }

    updateFeature(name, updates)
    const parts: string[] = []
    if (updates.title) parts.push(`title="${updates.title}"`)
    if (updates.description) parts.push(`desc="${updates.description}"`)
    if (updates.branch) parts.push(`branch=${updates.branch}`)
    if (updates.pr) parts.push(`pr=#${updates.pr.number}`)
    if (updates.scope) parts.push(`scope=${updates.scope}`)
    if (updates.tags) parts.push(`tags=${updates.tags.join(",")}`)
    console.log(`UPDATED: ${name} ${parts.join(" ")}`)
  })

const reposCmd = fleet.command("repos")
  .description("Manage repo shortname index")

reposCmd.command("list")
  .description("List all indexed repos")
  .action(() => {
    const repos = readRepos()
    console.log("REPOS:")
    for (const [key, val] of Object.entries(repos)) {
      console.log(`  ${key}\t${val}`)
    }
  })

reposCmd.command("add")
  .description("Add a repo to the index")
  .argument("[path]", "Path to repo", ".")
  .action((path) => {
    const resolved = resolve(path)
    const repos = readRepos()
    repos[basename(resolved)] = resolved
    writeRepos(repos)
    console.log(`ADDED: ${basename(resolved)} -> ${resolved}`)
  })

reposCmd.command("rm")
  .description("Remove a repo from the index")
  .argument("<name>", "Repo shortname to remove")
  .action((name) => {
    const repos = readRepos()
    delete repos[name]
    writeRepos(repos)
    console.log(`REMOVED: ${name}`)
  })

fleet.command("install")
  .description("Install fleet to ~/.local/bin for PATH availability")
  .action(() => {
    const scriptPath = realpathSync(import.meta.path)
    const binDir = join(HOME, ".local", "bin")
    const linkPath = join(binDir, "fleet")

    mkdirSync(binDir, { recursive: true })

    if (existsSync(linkPath)) {
      try {
        const stat = lstatSync(linkPath)
        if (stat.isSymbolicLink()) {
          const target = readlinkSync(linkPath)
          const resolvedTarget = resolve(join(HOME, ".local", "bin"), target)
          if (resolvedTarget === scriptPath) {
            console.log(`ALREADY_INSTALLED: ${linkPath} -> ${scriptPath}`)
            return
          }
          unlinkSync(linkPath)
          console.log(`REPLACED: old symlink removed`)
        } else {
          console.error(`ERROR: ${linkPath} exists and is not a symlink. Remove it manually.`)
          process.exit(1)
        }
      } catch (e) {
        console.error(`ERROR: Could not inspect ${linkPath}: ${e}`)
        process.exit(1)
      }
    }

    symlinkSync(scriptPath, linkPath)
    console.log(`INSTALLED: ${linkPath} -> ${scriptPath}`)

    const pathDirs = (process.env.PATH ?? "").split(":")
    if (!pathDirs.includes(binDir)) {
      console.log(`\nWARNING: ${binDir} is not in your PATH`)
      console.log(`Add it to your shell config:`)
      console.log(`  fish:  fish_add_path $HOME/.local/bin`)
      console.log(`  bash:  echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc`)
      console.log(`  zsh:   echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc`)
    } else {
      console.log(`PATH: ~/.local/bin is already in PATH`)
    }

    const completionsDir = join(HOME, ".config", "fish", "completions")
    if (existsSync(join(HOME, ".config", "fish"))) {
      mkdirSync(completionsDir, { recursive: true })
      const completionsPath = join(completionsDir, "fleet.fish")
      const subcommands = [
        ["spawn", "Create a new feature session"],
        ["status", "Snapshot of all active features"],
        ["check", "Detailed state of one feature"],
        ["check-active", "State of working/picker/blocked sessions"],
        ["pr", "Monitor PR: CI, reviews, comments, merge state"],
        ["poll", "Non-blocking event + state check (used by hooks)"],
        ["send", "Send text to a session"],
        ["send-multi", "Send message to multiple sessions"],
        ["watch", "Block until fleet events occur"],
        ["kill", "Kill feature sessions"],
        ["list", "List fleet-managed tmux sessions"],
        ["pick", "Select option in a picker"],
        ["keys", "Send raw tmux keys"],
        ["recover", "Reconcile registry after restart"],
        ["prune", "Trim events.jsonl"],
        ["desc", "Update feature description"],
        ["relay", "Relay output from one session to another"],
        ["share", "Share a file with multiple sessions"],
        ["repos", "Manage repo shortname index"],
        ["install", "Install fleet to ~/.local/bin"],
        ["uninstall", "Remove fleet from ~/.local/bin"],
      ]
      const featureCompletion = `function __fleet_features\n    set -l reg "$HOME/.claude/fleet/registry.json"\n    test -f "$reg" && jq -r '.features | keys[]' "$reg" 2>/dev/null\nend`
      const lines = [
        "# fleet CLI completions (auto-generated by fleet install)",
        featureCompletion,
        "",
        "complete -c fleet -f",
        ...subcommands.map(([cmd, desc]) => `complete -c fleet -n '__fish_use_subcommand' -a '${cmd}' -d '${desc}'`),
        "",
        "# Feature name completions for commands that take a feature argument",
        ...["check", "pr", "send", "kill", "pick", "keys", "desc", "relay"].map(
          cmd => `complete -c fleet -n '__fish_seen_subcommand_from ${cmd}' -a '(__fleet_features)'`
        ),
      ]
      writeFileSync(completionsPath, lines.join("\n") + "\n")
      console.log(`COMPLETIONS: ${completionsPath}`)
    }
  })

fleet.command("uninstall")
  .description("Remove fleet from ~/.local/bin")
  .action(() => {
    const linkPath = join(HOME, ".local", "bin", "fleet")

    if (!existsSync(linkPath)) {
      console.log(`NOT_INSTALLED: ${linkPath} does not exist`)
      return
    }

    const stat = lstatSync(linkPath)
    if (!stat.isSymbolicLink()) {
      console.error(`ERROR: ${linkPath} is not a symlink. Remove it manually.`)
      process.exit(1)
    }

    unlinkSync(linkPath)
    console.log(`UNINSTALLED: ${linkPath} removed`)

    const completionsPath = join(HOME, ".config", "fish", "completions", "fleet.fish")
    if (existsSync(completionsPath)) {
      unlinkSync(completionsPath)
      console.log(`COMPLETIONS_REMOVED: ${completionsPath}`)
    }
  })

async function capturePaneOutput(session: string, lines = 50): Promise<string> {
  return (await $`tmux capture-pane -t ${session}:claude -p -S -${lines}`.quiet().nothrow()).text().trim()
}

fleet.command("relay")
  .description("Capture output from one session and send it to another with context")
  .argument("<from>", "Source feature name")
  .argument("<to>", "Target feature name")
  .argument("<context>", "Context message to prefix the relayed output")
  .option("--lines <n>", "Number of pane lines to capture", "50")
  .action(async (from, to, context, opts) => {
    const fromFeat = requireFeature(from)
    const toFeat = requireFeature(to)
    const lines = parseInt(opts.lines)

    const { state: fromState } = await checkSessionState(fromFeat.tmuxSession)
    if (fromState === "gone" || fromState === "exited" || fromState.startsWith("crashed")) {
      console.error(`ERROR: Source session '${from}' is ${fromState}`)
      process.exit(1)
    }

    const { state: toState } = await checkSessionState(toFeat.tmuxSession)
    if (toState === "gone" || toState === "exited" || toState.startsWith("crashed")) {
      console.error(`ERROR: Target session '${to}' is ${toState}`)
      process.exit(1)
    }
    if (toState === "picker") {
      console.error(`ERROR: Target session '${to}' is showing a picker. Dismiss it first.`)
      process.exit(1)
    }
    if (toState === "blocked") {
      console.error(`ERROR: Target session '${to}' is waiting for confirmation. Respond first.`)
      process.exit(1)
    }

    const output = await capturePaneOutput(fromFeat.tmuxSession, lines)
    if (!output) {
      console.error(`ERROR: No output captured from '${from}'`)
      process.exit(1)
    }

    const message = `${context}\n\n--- Output from session '${from}' ---\n${output}\n--- End output ---`
    await tmuxSend(toFeat.tmuxSession, message)

    logEvent(from, "relayed", { to, context })
    console.log(`RELAYED: ${from} -> ${to} (${lines} lines, context: "${context}")`)
  })

fleet.command("share")
  .description("Send a file path and instruction to multiple sessions")
  .argument("<file-path>", "Path to the file to share")
  .argument("<sessions>", "Comma-separated feature names")
  .argument("<instruction>", "Instruction to send along with the file")
  .action(async (filePath, sessionsStr, instruction) => {
    const resolvedPath = resolve(filePath)
    if (!existsSync(resolvedPath)) {
      console.error(`ERROR: File not found: ${resolvedPath}`)
      process.exit(1)
    }

    const names = sessionsStr.split(",").map((n: string) => n.trim()).filter(Boolean)
    if (names.length === 0) {
      console.error("ERROR: Provide comma-separated feature names")
      process.exit(1)
    }

    const message = `${instruction}\n\nPlease read this file: ${resolvedPath}`

    let sent = 0
    for (const name of names) {
      const feat = getFeature(name)
      if (!feat) {
        console.log(`SKIP: ${name} not found`)
        continue
      }
      const { state } = await checkSessionState(feat.tmuxSession)
      if (["gone", "exited"].includes(state) || state.startsWith("crashed")) {
        console.log(`SKIP: ${name} is ${state}`)
        continue
      }
      if (state === "picker") {
        console.log(`SKIP: ${name} is showing a picker`)
        continue
      }
      if (state === "blocked") {
        console.log(`SKIP: ${name} is waiting for confirmation`)
        continue
      }

      await tmuxSend(feat.tmuxSession, message)
      console.log(`SENT to ${name} (state was ${state})`)
      sent++
    }

    logEvent("share", "shared", { file: resolvedPath, sessions: names, instruction })
    console.log(`\nSHARED: ${resolvedPath} -> ${sent}/${names.length} session(s)`)
  })

fleet.parse()
