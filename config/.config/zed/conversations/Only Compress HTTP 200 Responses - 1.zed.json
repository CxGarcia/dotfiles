{"id":"9e1d88c8-d736-4a84-a146-bd055c641342","zed":"context","version":"0.4.0","text":"\n\n\n```go commonlib/servers/httpserver/middleware/compression.go\npackage middleware\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"io\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\ntype (\n\t// GzipConfig defines the config for Gzip middleware.\n\tGzipConfig struct {\n\t\t// Skipper defines a function to skip middleware.\n\t\tSkipper func(c echo.Context) bool\n\n\t\t// MinLength defines the minimum length of response body to compress.\n\t\t// Default value is 1024 bytes.\n\t\tMinLength int\n\n\t\t// Level defines the compression level.\n\t\t// Default value is gzip.DefaultCompression.\n\t\tLevel int\n\t}\n\n\tgzipResponseWriter struct {\n\t\tio.Writer\n\t\techo.Response\n\t\tminLength      int\n\t\tbuf            *bytes.Buffer\n\t\tshouldCompress bool\n\t}\n)\n\nvar (\n\t// Default config\n\tDefaultGzipConfig = GzipConfig{\n\t\tSkipper:   DefaultSkipper,\n\t\tMinLength: 1024,\n\t\tLevel:     gzip.DefaultCompression,\n\t}\n\n\tgzipPool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn gzip.NewWriter(io.Discard)\n\t\t},\n\t}\n)\n\n// DefaultSkipper returns false which processes the middleware.\nfunc DefaultSkipper(c echo.Context) bool {\n\treturn false\n}\n\n// Gzip returns a middleware which compresses HTTP response using gzip compression\n// scheme.\nfunc Gzip() echo.MiddlewareFunc {\n\treturn GzipWithConfig(DefaultGzipConfig)\n}\n\n// GzipWithConfig returns a Gzip middleware with config.\nfunc GzipWithConfig(config GzipConfig) echo.MiddlewareFunc {\n\t// Defaults\n\tif config.Skipper == nil {\n\t\tconfig.Skipper = DefaultGzipConfig.Skipper\n\t}\n\tif config.MinLength <= 0 {\n\t\tconfig.MinLength = DefaultGzipConfig.MinLength\n\t}\n\tif config.Level == 0 {\n\t\tconfig.Level = DefaultGzipConfig.Level\n\t}\n\n\treturn func(next echo.HandlerFunc) echo.HandlerFunc {\n\t\treturn func(c echo.Context) error {\n\t\t\tif config.Skipper(c) {\n\t\t\t\treturn next(c)\n\t\t\t}\n\n\t\t\t// Check if client accepts gzip compression\n\t\t\tacceptEncoding := c.Request().Header.Get(echo.HeaderAcceptEncoding)\n\t\t\tsupportsGzip := strings.Contains(acceptEncoding, \"gzip\")\n\n\t\t\tif !supportsGzip {\n\t\t\t\treturn next(c)\n\t\t\t}\n\n\t\t\tres := c.Response()\n\t\t\tgw := gzipPool.Get().(*gzip.Writer)\n\t\t\tdefer gzipPool.Put(gw)\n\n\t\t\t// Create new gzip response writer\n\t\t\tgrw := &gzipResponseWriter{\n\t\t\t\tWriter:    gw,\n\t\t\t\tResponse:  *res,\n\t\t\t\tminLength: config.MinLength,\n\t\t\t\tbuf:       new(bytes.Buffer),\n\t\t\t}\n\n\t\t\tgw.Reset(res.Writer)\n\t\t\tdefer gw.Close()\n\n\t\t\tc.Response().Writer = grw\n\t\t\treturn next(c)\n\t\t}\n\t}\n}\n\nfunc (g *gzipResponseWriter) Write(b []byte) (int, error) {\n\tif g.Header().Get(echo.HeaderContentEncoding) == \"gzip\" {\n\t\treturn g.Writer.Write(b)\n\t}\n\n\t// Write to buffer\n\tn, err := g.buf.Write(b)\n\tif err != nil {\n\t\treturn n, err\n\t}\n\n\t// Check if response should be compressed\n\tif g.buf.Len() >= g.minLength {\n\t\tg.Header().Set(echo.HeaderContentEncoding, \"gzip\")\n\t\tg.Header().Del(echo.HeaderContentLength)\n\n\t\t// Write buffer to gzip writer\n\t\t_, err = g.Writer.Write(g.buf.Bytes())\n\t\treturn n, err\n\t}\n\n\t// Write buffer to original writer\n\treturn g.Response.Writer.Write(g.buf.Bytes())\n}\n```\n\nLet's make it so it only compresses responses with 200 status code\n\nI'll modify the code to only apply gzip compression when the response status code is 200 (OK). Here's how we can update the code:\n\n```go\nfunc (g *gzipResponseWriter) Write(b []byte) (int, error) {\n    // If already gzipped, write directly\n    if g.Header().Get(echo.HeaderContentEncoding) == \"gzip\" {\n        return g.Writer.Write(b)\n    }\n\n    // Write to buffer\n    n, err := g.buf.Write(b)\n    if err != nil {\n        return n, err\n    }\n\n    // Check if response should be compressed:\n    // 1. Response status must be 200\n    // 2. Buffer length must be >= minimum length\n    if g.Status() == 200 && g.buf.Len() >= g.minLength {\n        g.Header().Set(echo.HeaderContentEncoding, \"gzip\")\n        g.Header().Del(echo.HeaderContentLength)\n\n        // Write buffer to gzip writer\n        _, err = g.Writer.Write(g.buf.Bytes())\n        return n, err\n    }\n\n    // Write buffer to original writer\n    return g.Response.Writer.Write(g.buf.Bytes())\n}\n```\n\nThe key change is adding the `g.Status() == 200` condition in the if statement that determines whether to compress the response. Now, compression will only be applied when both conditions are met:\n1. The response status code is 200\n2. The response body length is greater than or equal to the minimum length (default 1024 bytes)\n\nThis means that error responses (4xx, 5xx) and other non-200 responses will not be compressed, even if they meet the minimum length requirement.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":74}}},{"id":{"replica_id":0,"value":32},"start":3016,"metadata":{"role":"assistant","status":{"Error":"Failed to connect to API: 400 Bad Request {\"error\":{\"message\":\"The requested model is not supported.\",\"param\":\"model\",\"code\":\"model_not_supported\",\"type\":\"invalid_request_error\"}}\n"},"timestamp":{"replica_id":0,"value":75}}},{"id":{"replica_id":0,"value":54},"start":3017,"metadata":{"role":"assistant","status":"Canceled","timestamp":{"replica_id":0,"value":76}}},{"id":{"replica_id":0,"value":66},"start":4445,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":77}}}],"summary":"Only Compress HTTP 200 Responses","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":2948},"icon":"File","label":"commonlib/servers/httpserver/middleware/compression.go","metadata":{"path":"commonlib/servers/httpserver/middleware/compression.go"}}]}